# 영속성 관리

## 엔터티 매니저

엔터티의 저장, 수정, 삭제, 조회 등 엔터티와 관련된 일을 처리한다. 가상의 데이터베이스라 할 수 있다.

---

## 엔터티 매니저 팩토리 → 엔터티 매니저

데이터 베이스를 하나만 사용하는 애플리케이션은 EntityManager Factory를 하나만 생성한다.

```java
EntityManager emf = Persistence.createEntityManagerFactory("jpabook");
```

    > createEntityManager() : META-INF/persistence.xml에 있는 정보를 바탕으로 EntityManagerFactory를 생성한다.

    팩토리 매니저 생성 이후 필요할 때마다 엔터티 매니저를 생성하면 된다.

```java
EntityManager em = emf.createEntityManager();
```

> 엔터티 매니저 팩토리는 여러 스레드가 동시에 접근해도 안전하므로 서로 다른 스레드 간에 공유할 수 있지만, 엔터티 매니저는 여러 스레드가 동시에 접근하면 동시성 문제가 발생하게 된다. 따라서 스레드 간에 공유를 피해야 한다.

---

## 영속성 컨텍스트

엔터티를 영구 저장하는 환경을 말한다. 엔터티 매니저로 엔터티를 저장하거나 조회하면 엔터티 매니저는 영속성 컨텍스트에 엔티티를 보관 및 관리한다.

```java
em.persist(member);
```

> 조회한 엔티티도 영속성 컨텍스트가 관리 하는 영속 상태

---

## 엔티티 생명 주기

- 비영속 : 영속성 컨텍스트와 관계가 없는 상태
- 영속 : 영속성 컨텍스트에 저장된 상태
- 준영속 : 영속성 컨텍스트에 저장 되었다가 분리된 상태
- 삭제 : 삭제된 상태

---

## 영속성 컨텍스트의 특징

1. 영속성 컨텍스트는 식별자 값으로 구분한다. (@Id) 따라서 반드시 필요하다.
2. 트랜잭션을 커밋하는 순간 영속성 컨텍스트에 저장된 엔티티를 데이터베이스에 반영한다. 이를 플러시라 한다.

### 엔티티 조회

- 1차 캐시 : 영속성 컨텍스트 내부에 가지고 있는 캐시. 영속 상태의 엔티티는 모두 1차 캐시에 저장 된다.
- 1차 캐시의 키는 식별자 값이며, 식별자 값은 데이터베이스 기본 키와 매핑되어 있다. 따라서 영속성 컨텍스트에 데이터를 저장하고 조회하는 모든 기준은 데이터베이스 기본 키 값이다.
- em.find()를 호출하면 먼저 1차 캐시에서 먼저 찾고, 없으면 데이터베이스에서 조회한다.

**데이터베이스에서 조회**

- 조회한 데이터가 1차 캐시에 없으면 데이터베이스를 조회해서 엔티티를 생성한다. 그 이후 1차 캐시에 저장한 후 영속 상태의 엔티티를 반환한다.

**영속 엔티티의 동일성 보장**

> 영속성 컨텍스트는 1차 캐시에 있는 같은 엔티티 인스턴스를 반환한다. 따라서 영속성 컨텍스트는 성능상 이점과 엔티티의 동일성을 보장한다.

```java
Member a = em.find(Member.class, "member1");
Member b = em.find(Member.class, "member1");

System.out.println(a == b); // 참
```

### 엔티티 등록

엔티티 매니저는 트랜잭션을 커밋하기 직전까지 데이터베이스에 엔티티를 저장하지 않고 내부 쿼리 저장소에 INSERT SQL을 모아둔다. 이후 트랜잭션을 커밋할 때 모아둔 쿼리를 데이터베이스에 보내는데, 이것을 트랜잭션을 지원하는 '쓰기 지연'이라 한다.

```java
EntityManager em = cmf.createEntityManager();
EntityTransaction transaction = em.getTransaction();
transaction.begin();

em.persist(memberA);
em.persist(memberB);

transaction.commit();
```

### 엔티티 수정

JPA로 엔티티를 수정할 때는 단순히 엔티티를 조회해서 데이터만 변경하면 된다. 별도의 메서드 실행 없이 이러한 변경을 자동으로 데이터베이스에 반영하게 되는데, 이를 '변경 감지'라 한다.

```java
EntityManager em = emf.createEntityManager();
EntityTransaction transaction = em.getTransaction();
transaction.begin();

Member memberA = em.find(Member.class, "memberA");

memberA.setUsername("hi");
memberA.setAge(10);

transaction.commit();
```

    자세한 절차는 다음과 같다.

1. JPA는 엔티티를 영속성 컨텍스트에 보관할 때, 최초 상태를 복사해서 저장해두는데 이것을 '스냅샷'이라 한다.
2. 플러시 시점에 스냅샷과 엔티티를 비교한 뒤 변경된 엔티티를 찾는다.
3. 스냅샷과 엔티티를 비교해서 변경사항이 있으면 수정 쿼리를 쓰기 지연 SQL 저장소에 보낸다.
4. 쓰기 지연 저장소의 SQL을 데이터베이스에 보낸다.
5. 데이터베이스 트랜잭션을 커밋한다.

### 엔티티 삭제

엔티티 삭제 역시, 등록과 비슷하게 삭제 쿼리를 쓰기 지연 SQL에 저장한 후, 트랜잭션을 커밋해서 플러시를 호출하면 실제 데이터베이스에 삭제 쿼리를 전달한다.

```java
Member memberA = em.find(Member.class, "memberA");
em.remove(memberA);   // 엔티티 삭제
```

---

## 플러시

영속성 컨텍스트의 변경 내용을 데이터베이스에 반영하는 것.
다음의 세 가지 방법으로 호출할 수 있다.

1. em.flush()
2. 트랜잭션 커밋 시 플러시 자동 호출
3. JPQL 쿼리 실행 시 플러시가 자동 호출

---

## 준영속

영속성 컨텍스트가 관리하는 영속 상태의 엔티티가 영속성 컨텍스트에서 분리된 것.
다음의 세 가지 방법으로 준영속 상태로 전환 시킬 수 있다.

1. em.detach(entity) : 특정 엔터티만 준영속 상태로 전환
2. em.clear() : 영속성 컨텍스트를 완전히 초기화
3. em.close() : 영속성 컨텍스트를 종료

### 준영속 상태의 특징

1. 비영속 상태에 가깝다.
2. 식별자 값을 가지고 있다 : 비영속 상태는 식별자 값이 없을 수도 있지만, 준영속 상태는 이미 한 번 영속 상태였으므로 반드시 식별자 값을 가지고 있다.
3. 지연 로딩을 할 수 없다 : 지연로딩이란 프록시 객체를 로딩해두고 해당 객체를 사용할 때 영속성 컨텍스트를 통해 데이터를 불러오는 방법이다.

### 병합: merge()

준영속 상태의 엔티티를 다시 영속 상태로 변경하는 방법. 준영속 상태의 엔티티를 받아서 그 정보로 새로운 영속 상태의 엔티티를 반환한다.

```java
Member mergeMember = em.merge(member);
```
