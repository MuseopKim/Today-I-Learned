# 스프링이 사랑한 디자인 패턴

프로그램을 작성하다 보면 마주하게 되는 비슷한 상황들이 있다. 이럴 때 이전의 많은 개발자들이 고민하고 정제한 개발 및 표준 설계 패턴이 있는데, 이를 디자인 패턴이라 한다.

디자인 패턴은 실제 개발 현장에서 비즈니스 요구사항을 처리 하면서 만들어진 다양한 해결책 중 많은 개발자들이 인정한 베스트 프랙티스라 할 수 있다.

스프링은 객체 지향의 특성, 설계 원칙을 극한까지 적용한 프레임워크이기 때문에 스프링을 공부하면 객체 지향 설계의 베스트 프랙티스인 디자인 패턴을 만날 수 있다.

---

## 어댑터 패턴 (Adapter Pattern)

여기서 말하는 어댑터의 역할은 서로 다른 두 인터페이스 사이에 통신이 가능하게 하는 것이다. 스프링에의 대표적인 어댑터 패턴이라 하면 JDBC를 들 수 있다. 어댑터 패턴을 이용해 다양한 데이터베이스 시스템을 단일한 인터페이스로 조작할 수 있게 해준다.

개방 폐쇄 원칙 (OCP) 를 활용한 설계 패턴이라 할 수 있다. JDBC, JRE가 어댑터의 역할을 수행하고 있는 것이다.

```java
// ServiceA
public class AdapterServiceA {

	ServiceA sa = new ServiceA();

	void runService() {
		sa.runServiceA();
	}
}

// ServiceB
public class AdapterServiceB {

	ServiceB sb = new ServiceB();

	void runService() {
		sb.runServiceB();
	}
}

// main
public class ClientWithAdapter {
	public static void main(String[] args) {
		AdapterServiceA asa1 = new AdapterServiceA();
		AdapterServiceB asb1 = new AdapterServiceB();

		asa1.runService();
		asb1.runService();
	}
}
```

위의 코드는 인터페이스를 활용하면 더 개선할 수 있다.

어댑터 패턴은 합성, 즉 객체를 속성으로 만들어서 참조하는 디자인 패턴이다.

즉, **호출 당하는 쪽의 메서드를 호출하는 쪽의 코드에 대응하도록 중간에 변환기를 통해 호출하는 패턴을 말한다.**

---

## 프록시 패턴 (Proxy Pattern)

프록시는 대리자, 대변인이라는 뜻을 가진다. 프록시 패턴의 경우 실제 서비스 객체가 가진 메서드와 같은 이름의 메서드를 사용하는데, 이를 위해 인터페이스를 사용하게 된다. 인터페이스를 사용하면 서비스 객체가 들어갈 자리에 대리자 객체를 대신 투입할 수 있다.

이와 같이 실행하면 실제 서비스 객체를 통해 메서드를 호출하고 반환 값을 받는지, 아니면 대리자 객체를 통해 호출하는지 알 수 없게 된다.

프록시 패턴의 중요 포인트를 다시 한번 짚어 보면 다음과 같다.

- 대리자는 실제 서비스와 같은 이름의 메서드를 구현한다. (인터페이스 사용)
- 대리자는 실제 서비스에 대한 참조 변수를 갖는다. (합성)
- 대리자는 실제 서비스의 같은 이름을 가진 메서드를 호출하고, 결과를 반환한다.
- 대리자는 실제 서비스의 메서드 호출 전후에 별도의 로직을 수행할 수 있다.

  프록시 패턴은 개방 폐쇄 원칙 (OCP)와 의존 역전 원칙 (DIP) 이 적용된 설계 패턴이라 할 수 있다.

---

## 데코레이터 패턴 (Decorator Pattern)

프록시 패턴과 구현 방법이 같은데, 프록시 패턴은 클라이언트가 돌려 받는 반환 값을 조작하지 않고 그대로 반환하는 반면, 데코레이터 패턴은 클라이언트가 받을 반환 값에 장식을 덧입힌다.

데코레이터 패턴의 중요 포인트는 다음과 같다.

- 장식자는 실제 서비스와 같은 이름의 메서드를 구현한다. (인터페이스 사용)
- 장식자는 실제 서비스에 대한 참조 변수를 갖는다. (합성)
- 장식자는 실제 서비스의 같은 이름을 가진 메서드를 호출하고, 그 반환 값에 장식을 더해 클라이언트에게 돌려준다.
- 장식자는 실제 서비스의 메서드 호출 전후에 별도의 로직을 수행할 수도 있다.

  데코레이터 패턴은 프록시 패턴과 동일한 구조로 OCP, DIP 가 적용된 디자인 패턴이다.

---

## 싱글턴 패턴 (Singleton Pattern)

인스턴스를 하나만 만들어서 사용하기 위한 패턴이다. 주로 커넥션 풀, 스레드 풀, 디바이스 설정 객체 등 인스턴스를 여러 개 만들 필요가 없는 케이스에 사용한다.

싱글턴 패턴을 적용할 경우 의미상 두 개의 객체가 존재할 수 없다. 이를 구현하려면 객체 생성을 위한 new에 제약을 걸어야 한다. 또한 만들어진 단일 객체를 반환할 수 있는 메서드가 필요하다. 이러한 구현 조건을 정리하면 다음과 같다.

- 생성자에 private 접근 제한자 적용
- 유일한 단일 객체를 반환할 수 있는 정적 메서드 필요
- 유일한 단일 객체를 참조할 정적 참조 변수 필요
- 단일 객체이기 때문에 상태를 갖지 않아야 함

```java
public class Singleton {
	static Singleton singletonObject;

	private Singleton() { };

	public static Singleton getInstance() {
		if (singletonObject == null) {
			singletonObject = new Singleton();
		}

		return singletonObject;
	}
}
```

싱글턴 패턴은 단일 객체를 공유하기 때문에 속성을 갖지 않게 해야한다. 다만 읽기 전용 속성을 갖는 것은 문제가 되지 않는다.

---

## 템플릿 메서드 패턴 (Template Method Pattern)

상위 클래스에 공통 로직을 수행하는 템플릿 메서드와 하위 클래스에 오버라이딩을 강제하는 추상 메서드 또는 선택적으로 오버라이딩 할 수 있는 훅 메서드를 두는 패턴을 템플릿 메서드 패턴이라 한다.

---

## 팩토리 메서드 패턴 (Factory Method Pattern)

팩토리 메서드는 객체를 생성 반환하는 메서드를 말한다. 여기서 '팩토리 메서드 패턴' 이라 함은 하위 클래스에서 팩토리 메서드를 오버라이딩해서 객체를 반환하게 하는 것을 의미한다.

**오버라이드된 메서드가 객체를 반환하는 패턴이라 할 수 있다.**

---

## 전략 패턴 (Strategy Pattern)

전략 패턴은 다음의 세 가지 요소가 중요하다.

- 전략 메서드를 가진 전략 객체
- 전략 객체를 사용하는 컨텍스트(전략 객체의 사용자 / 소비자)
- 전략 객체를 생성해 컨텍스트에 주입하는 클라이언트(제3자, 전략 객체의 공급자)

  템플릿 메서드 패턴과 굉장히 유사하다.

  전략 패턴 역시 OCP, DIP가 적용 되며, **클라이언트가 전략을 생성해 전략을 실행할 컨텍스트에 주입하는 패턴** 을 말한다.

---

## 템플릿 콜백 패턴(Template Callback Pattern - 견본 / 회신 패턴)

전략 패턴의 변형으로, 스프링의 DI에서 사용하는 특별한 형태의 전략이다. 템플릿 콜백 패턴은 전략 패턴과 모든 것이 동일한데, 전략을 익명 내부 클래스로 정의해서 사용한다는 특징이 있다.

템플릿 콜백 패턴은 전략 패턴의 일종으로, OCP와 DIP가 적용되어 있다. 다시 한번 정리하면
**전략을 익명 내부 클래스로 구현한 전략 패턴** 이라 할 수 있다.
