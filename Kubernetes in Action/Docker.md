# Docker

## docker run

```bash
> docker run busybox echo "Hello world"
```

docker run을 수행하면 해당 이미지가 로컬에 존재하는지 체크한다. 만약 존재하지 않는다면 도커 허브 레지스트리에서 해당 이미지를 다운로드 한다. 이미지의 다운이 완료되면 이미지로부터 컨테이너를 생성하고 컨테이너 내부에서 명령어를 실행한다.

### 컨테이너 이미지에 버전 지정하기

```bash
> docker run <image>:<tag>
```

---

## Dockerfile

애플리케이션을 이미지로 패키징하기 위해 Dockerfile을 생성한다. Dockerfile에는 도커가 이미지를 생성하기 위해 수행해야 할 지시사항들이 담겨 있다.

```docker
# BASE IMAGE 지정
FROM node

# 현 디렉토리의 app.js를 이미지의 루트 디렉토리에 복사
ADD ./app.js /app.js

# 이미지를 실행 했을 때 수행돼야 할 명령어 정의
ENTRYPOINT ["node", "app.js"];
```

### 기본 이미지 선택

Dockerfile에서는 베이스 이미지를 지정해야한다. 예를 들어 Node.js 애플리케이션 실행을 위해서는 node 바이너리 실행파일이 포함된 이미지가 필요하다. 바이너리가 포함된 다른 이미지나 Ubuntu와 같은 리눅스 배포판을 사용할 수도 있다. 이 예시에서 사용한 node 이미지의 경우 Node.js 애플리케이션 실행을 위해 만들어진 특별한 이미지다. 애플리케이션을 실행하기 위한 모든 것을 포함하고 있으므로 기본 이미지로 사용한다.

---

## 컨테이너 이미지 생성

```bash
> docker build -t kubia .
```

이 명령어는 도커에게 현 디렉토리의 콘텐츠를 기반으로 kubia라 부르는 이미지를 빌드하라고 요청한다. 도커는 디렉토리 내에 Dockerfile을 살펴보고 파일에 명시된 지시 사항에 근거해 이미지를 빌드한다. 이는 다음과 같은 순서로 실행된다.

1. docker build kubia .
2. 도커 클라이언트가 디렉토리의 컨텐츠를 데몬에 업로드
3. 이미지가 아직 로컬에 없는 경우 도커가 node 이미지를 pull
4. 새로운 이미지를 빌드

### 이미지 빌드 과정

이미지를 빌드 하기 위해 디렉토리 전체 콘텐츠가 도커 데몬에 업로드 되고 그곳에서 이미지가 빌드된다. 리눅스가 아닌 OS에서 도커를 사용하는 경우 도커 클라이언트는 OS에, 데몬은 가상머신 내부에서 실행된다. 빌드 프로세스 동안 이미지가 사용자 컴퓨터에 저장되어 있지 않다면 도커는 기본 이미지를 퍼블릭 이미지 레포지토리에서 가져온다.

### 이미지 레이어

이미지는 하나의 큰 바이너리 덩어리가 아닌 여러 개의 레이어로 구성된다. (레이어마다 한 행의 pull complete가 다수) 또한 서로 다른 이미지가 여러 개의 레이어를 공유할 수 있어 효율적이다. 예를 들면 동일한 기본 이미지를 바탕으로 다수의 이미지를 생성 하더라도 기본 이미지를 구성하는 모든 레이어는 단 한 번만 저장된다.

이미지를 빌드하는 동안 기본 이미지의 모든 레이어를 가져온 다음 도커는 그 위에 새로운 레이어를 생성하고 실행 할 node파일을 그 위에 추가한다. 그리고 이미지가 실행 될 때 수행 할 명령을 지정하는 또 하나의 레이어를 추가한다.

---

## 컨테이너 이미지 실행

```bash
> docker run --name kubia-container -p 8080:8080 -d kubia
```

- `--name kubia-conatiner` : kubia-conatiner라는 이름의 새로운 컨테이너를 실행한다.
- `-p 8080:8080` : 로컬의 8080포트와 컨테이너 내부의 8080포트가 맵핑된다. (http://localhost:8080으로 애플리케이션 접근 가능)
- `-d` : 콘솔에서 분리 돼 백그라운드에서 실행됨을 의미한다.
- 데몬이 실행 중이 아니라면 [localhost](http://localhost) 대신 데몬이 실행 중인 가상머신의 호스트 이름이나 IP를 사용해야한다. (`DOCKER_HOST` ) 환경변수를 통해 확인 가능

### 실행중인 컨테이너 조회

```bash
> docker ps
```

### 실행중인 컨테이너에 대한 자세한 정보 조회

```bash
> docker inspect kubia-container
```

---

## 실행 중인 컨테이너 내부 탐색

하나의 컨테이너에 여러 개의 프로세스가 실행될 수 있기 때문에 추가 프로세스를 실행해서 컨테이너 내부를 살펴볼 수 있다.

```bash
> docker exec -it kubia-container /bin/bash
```

- bash 프로세스는 컨테이너의 메인 프로세스와 동일한 리눅스 네임스페이스를 갖는다. 따라서 컨테이너 내부를 탐색할 수 있다. 리눅스의 네임 스페이스를 이용하여 볼 수 있는 범위를 한정해 컨테이너의 격리 기능을 제공한다.
- `-i` : 표준 입력을 오픈 상태로 유지한다. 쉘 명령어 입력을 위해 필요하다. 생략할 경우 명령어를 입력할 수 없다.
- `-t` : pseudo 터미널을 할당한다. 생략할 경우 명령어 프롬프트가 화면에서 표시되지 않는다.

### 호스트 운영체제에서 실행 중인 컨테이너의 프로세스

```bash
> ps aux | grep app.js
```

호스트 OS에서 실행중인 프로세스를 조회하면 컨테이너에서 실행 중인 프로세스가 조회 되는데, 호스트 운영체제와 컨테이너 내부에서 조회한 프로세스의 ID가 다르다. 컨테이너는 자체 리눅스 PID 네임스페이스를 사용하여 고유의 시퀀스 번호를 가지고 분리된 프로세스 트리를 갖는다.

### 격리된 컨테이너 파일시스템

격리된 프로세스를 갖는 것과 마찬가지로 컨테이너는 격리된 파일 시스템을 가지고 있다. 컨테이너 내부에서 루트 디렉토리를 조회해보면 컨테이너 안의 파일만 보여준다.

---

## 컨테이너의 중지와 삭제

### 컨테이너 중지

```bash
> docker stop kubia-container
```

### 컨테이너의 삭제

```bash
> docker rm kubia-container
```

### 이미지 레지스트리에 이미지 푸시

도커 레지스트리에 이미지를 푸시하려면 레포지토리의 이름이 도커 허브 ID로 시작되어야만 한다.

### 이미지 추가 태그 지정

```bash
# 태그를 변경하는 것이 아닌 동일한 이미지에 태그를 추가하는 것
> docker tag kubia museopkim/kubia
```

### 도커 허브에 이미지 푸시

```bash
> docker push museopkim/kubia
```
