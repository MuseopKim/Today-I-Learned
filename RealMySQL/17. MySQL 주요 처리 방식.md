# MySQL 주요 처리 방식

## 풀 테이블 스캔

인덱스를 사용하지 않고 테이블의 데이터를 처음부터 끝까지 읽어 요청을 처리하는 방식이다. 다음과 같은 조건에 부합할 때 풀 테이블 스캔이 발생한다.

- 테이블 레코드 건수가 너무 적어서 인덱스를 읽는 것보다 풀 테이블 스캔이 더 빠른 경우
- WHERE 절, ON 절에 인덱스를 이용할 수 있는 적절한 조건이 없는 경우
- 인덱스 레인지 스캔을 이용할 수 있더라도 옵티마이저가 판단한 조건 일치 레코드 건수가 너무 많은 경우
- max_seeks_for_key 변수를 특정 값(N) 으로 설정하면 인덱스의 카디널리티, 셀렉티비티를 무시하고 최대 N건만 읽으면 된다고 판단하게 한다. 이 값을 작게 설정할수록 MySQL 서버가 인덱스를 더 사용하도록 유도한다.

  대부분의 DBMS는 풀 테이블 스캔을 실행할 때 한꺼번에 여러 개의 블록이나 페이지를 읽어오는 기능이 있고, 그 수를 조절할 수 있다. 하지만 MySQL은 풀 테이블 스캔을 실행할 때 한꺼번에 몇 개씩 페이지를 읽어올지 설정하는 변수가 없다. 그래서 MySQL은 풀 테이블 스캔을 실행할 때 디스크로부터 페이지를 하나씩만 읽어 오는 것으로 생각될때가 많은데, InnoDB 스토리지 엔진의 경우 이와 다르다.

  InnoDB 스토리지 엔진은 특정 테이블의 연속된 데이터 페이지가 읽히면 백그라운드 스레드에 의해 리드 어헤드 작업이 자동으로 시작된다.

> 리드 어헤드 - 어떤 영역의 데이터가 앞으로 필요해지리라는 것을 예측해서 요청이 오기 전 미리 디스크에서 읽어 InnoDB 버퍼 풀에 가져다 두는 것

리드 어헤드 작업으로 백그라운드 스레드가 페이지를 계속 읽으며 버퍼 풀에 저장해두면 포그라운드 스레드는 데이터를 가져다 사용한다. 이런 동작을 통해 쿼리가 빠른 속도로 처리될 수 있다.

---

## ORDER BY 처리 (Using filesort)

대부분의 SELECT 쿼리에서 정렬은 필수적으로 사용된다. 정렬을 처리하기 위해 인덱스를 이용하는 방법과 쿼리가 실행될 때 Filesort라는 별도의 처리를 이용하는 두 가지 처리 방법이 있다.

- 인덱스 이용 - INSERT, UPDATE, DELETE 쿼리가 실행될 때 인덱스가 정렬돼 있어서 순서대로 읽기만 하면 된다. 하지만 INSERT, UPDATE, DELETE 시 별도의 인덱스 추가 및 삭제 작업이 필요하며, 디스크 공간이 더 많이 필요하다.
- Filesort 이용 - 인덱스를 생성하지 않아도 되므로 인덱스를 이용할 때의 단점이 모두 커버된다. 정렬해야 할 레코드가 많지 않다면 메모리에서 Filesort가 처리 되므로 충분히 빠른 성능을 보여준다. 그러나 쿼리 실행 시 정렬이 처리되므로 레코드 수가 많다면 성능이 현저히 떨어질 수 있다.

### 소트 버퍼

MySQL은 정렬을 수행하기 위해 별도의 메모리 공간을 할당 받는데, 이 메모리 공간을 소트 버퍼라한다. 최대 사용 가능한 소트 버퍼의 공간은 sort_buffer_size라는 시스템 변수로 설정할 수 있다.

만약 정렬해야 할 레코드 수가 많다면 소트 버퍼로 할당된 공간으로는 부족하다. 이 경우 정렬 해야 할 레코드를 여러 조각으로 나누는데, 이 과정에서 임시 저장을 위해 디스크를 사용하게 된다. 각 버퍼 크기만큼만 메모리에 올려서 정렬을 수행하고, 그 결과를 디스크에 임시 저장하고, 다시 나머지 레코드를 버퍼 크기만큼 메모리에 올려 정렬하고, 디스크에 정렬 결과를 재병합하는 식으로 수행된다. 이를 멀티 머지`Multi-merge`라 표현한다.

---

## 정렬의 처리 방식

### 인덱스를 이용한 정렬

인덱스를 이용한 정렬을 위해서는 (조인 시) ORDER BY에 명시된 컬럼이 제일 먼저 읽는 테이블에 속하고, ORDER BY의 순서대로 생성된 인덱스가 있어야 한다.
또한 WHERE 절에 첫 번째 읽는 테이블의 컬럼에 대한 조건이 있다면 그 조건과 ORDER BY는 같은 같은 인덱스를 사용할 수 있어야 한다.

인덱스를 이용해 정렬이 처리되는 경우 실제 인덱스의 값이 정렬되어 있기 때문에 인덱스의 순서대로 읽기만 하면 된다.

### 드라이빙 테이블만 정렬

조인이 수행되면 결과 레코드의 수가 몇 배로 늘어난다. 그래서 조인을 실행하기 전에 첫 번째 테이블의 레코드를 먼저 정렬한 다음 조인을 실행하는 것이 좋다. 이를 위해서는 첫 번째 읽히는 테이블의 컬럼만으로 ORDER BY 절이 작성 되어야 한다.

### 임시 테이블을 이용한 정렬

쿼리가 여러 테이블을 조인하지 않고, 하나의 테이블로부터 SELECT 해서 정렬하는 경우라면 임시 테이블이 필요하지 않다. 그러나 2개 이상의 테이블을 조인하는 경우 임시 테이블이 필요할 수도 있다. 드라이빙 테이블만 정렬하는 상단의 케이스가 아니라면 항상 조인의 결과를 임시 테이블에 저장하고, 그 결과를 다시 정렬하는 과정을 거치게 된다.

---

## GROUP BY 처리

ORDER BY와 마찬가지로 쿼리가 스트리밍 처리를 할 수 없게 하는 요소다. GROUP BY는 HAVING절과 함께 사용될 수 있는데, HAVING절은 GROUP BY된 결과에 대해 필터링을 수행한다. GROUP BY에 사용된 조건은 인덱스를 사용해서 처리될 수 없으므로 HAVING절을 튜닝하려고 고민할 필요가 없다.

GROUP BY 작업이 인덱스를 사용하는 경우, 인덱스를 차례대로 이용하는 인덱스 스캔 방법과 인덱스를 건너 뛰며 읽는 루스 인덱스 스캔 두 가지 방법 중 하나로 수행된다. 인덱스를 사용하지 못하는 쿼리에서는 임시 테이블을 사용한다.

### 인덱스 스캔을 이용하는 GROUP BY(타이트 인덱스 스캔)

GROUP BY가 인덱스를 통해 처리되는 쿼리는 이미 정렬된 인덱스를 읽으면 되므로 추가적인 정렬 작업은 필요하지 않다.

### 루스 인덱스 스캔을 이용하는 GROUP BY

루스 인덱스 스캔 방식은 인덱스의 레코드를 건너뛰면서 필요한 부분만을 가져온다.

```sql
# 인덱스 - (emp_no + from_date)
SELECT emp_no
FROM salaries
WHERE from_date = '1985-03-01'
GROUP BY emp_no;
```

이 쿼리는 다음과 같은 순서로 실행된다.

1. emp_no + from_date 인덱스를 차례대로 스캔하면서 emp_no의 첫 번째 유일한 값 10001을 찾아낸다.
2. emp_no + from_date 인덱스에서 emp_no가 10001인 것 중에서 from_date 값이 1985-03-01인 레코드만 가져온다.
3. emp_no + from_date 인덱스에서 emp_no의 그 다음 유니크 값을 가져온다.
4. 앞선 단계에서 결과가 더 없으면 종료하고, 결과가 있다면 2번으로 돌아가 반복 수행한다.

### 임시 테이블을 사용하는 GROUP BY

GROUP BY의 기준 컬럼이 드라이빙 테이블에 있던, 드리븐 테이블에 있던 상관 없이 인덱스를 전혀 사용하지 못할 때는 이 방식으로 처리된다.

---

## DISTINCT 처리

특정 컬럼의 유니크한 값만을 조회하려면 쿼리에 DISTINCT를 사용해야 한다. DISTINCT는 집합 함수가 있는 경우와 없는 두 가지 경우의 적용 범위가 다르다. DISTINCT는 인덱스를 사용하지 못할 경우 항상 임시 테이블이 필요한데, Extra 컬럼에는 Using temporary가 출력되지 않는다.

### SELECT DISTINCT

셀렉트 되는 레코드 중에서 유니크한 레코드만 가져온다. 이 경우 GROUP BY와 같은 방식으로 처리가 되는데, 정렬이 보장되지 않는다.

```sql
SELECT DISTINCT emp_no FROM salaries;
```

DISTINCT는 레코드를 유니크하게 셀렉트 하는 것이지 컬럼을 유니크하게 조회하는 것이 아니다. 집합 함수 내부에서 사용된 DISTINCT가 아니라면 조회하는 컬럼의 조합이 유니크한 것들만 가져온다.

```sql
# first_name, last_name 조합이 유니크한 레코드를 조회
SELECT DISTINCT first_name, last_name FROM employees;
```

---

## 임시 테이블

MySQL 엔진이 스토리지 엔진으로부터 받아온 레코드를 정렬하거나 그룹핑 할 때는 내부적인 임시 테이블을 사용한다. 처음에는 메모리에 생성 됐다가 용량이 커지면 디스크로 옮겨진다. 원본 테이블의 스토리지 엔진과 관계없이 임시 테이블이 메모리를 사용할 때는 MEMORY스토리지 엔진을 사용하고, 디스크에 저장될 때는 MyISAM 스토리지 엔진을 사용한다. 다른 세션이나 쿼리에서는 이를 조회할 수 없고, 쿼리의 처리가 완료되면 자동으로 삭제된다.

### 임시 테이블이 필요한 쿼리

- ORDER BY, GROUP BY에 명시된 컬럼이 다른 쿼리
- ORDER BY, GROUP BY에 명시된 컬럼이 조인 순서상 첫 번째 테이블이 아닌 쿼리
- DISTINCT, ORDER BY가 동시에 쿼리에 존재하는 케이스
- DISTINCT가 인덱스로 처리되지 못하는 쿼리
- UNION, UNION DISTINCT가 사용된 쿼리
- UNION ALL이 사용된 쿼리
- 쿼리 실행 계획에서 select_type이 DERIVED인 쿼리

### 임시 테이블이 디스크에 생성되는 경우 (MyISAM 스토리지 엔진 사용)

내부 임시 테이블은 기본적으로 메모리 상에 만들어지지만 다음의 경우 메모리만으로 부족하여 디스크상에 MyISAM 테이블로 임시 테이블을 만든다.

- 임시 테이블에 저장해야 하는 내용 중 BLOB, TEXT 같은 대용량 컬럼이 존재
- 임시 테이블에 저장해야 하는 레코드 전체 크기나 UNION, UNION ALL에서 SELECT 되는 컬럼 중 길이가 512 바이트 이상인 컬럼이 존재
- GROUP BY, DISTINCT 컬럼에서 512바이트 이상인 크기의 컬럼이 존재 (MEMORY → MyISAM)
- 임시 테이블에 저장할 데이터의 전체 크기가 tmp_table_size, max_heap_table_size 시스템 설정 값보다 큰 경우 (MEMORY → MyISAM)

### 임시 테이블 관련 상태 변수

임시 테이블이 디스크에 생성 됐는지 메모리에 생성 됐는지 알아보고 싶다면 MySQL 서버의 상태 변수를 확인해보면 된다.

```sql
SHOW SESSION STATUS LIKE 'Created_tmp%';
```

- Created_tmp_tables : 쿼리 처리를 위해 만들어진 내부 임시 테이블의 개수를 누적하는 상태 값
- Created_tmp_disk_tables : 디스크 내부 임시 테이블이 만들어진 개수만 카운트

### 임시 테이블 관련 주의사항

레코드 건수가 많지 않으면 내부 임시 테이블이 메모리에 생성되고 MySQL 서버의 부하에 크게 영향을 미치지 않는다. 성능상의 이슈가 되는 부분은 디스크에 생성되는 케이스다. (자세한 예시는 p.357 참조)

---

## 테이블 조인

MySQL의 모든 버전에서 조인 방식은 네스티드 루프로 알려진 중첩된 루프와 같은 형태만 지원한다.

조인의 처리에서 어느 테이블을 먼저 읽을지를 결정하는 것은 성능에 영향을 미치는 상당히 중요한 요소이다. INNER JOIN은 조인 순서에 영향을 받지 않아 옵티마이저가 조인의 순설르 조절해서 다양한 방법으로 최적화를 할 수 있다. 그러나 OUTER JOIN의 경우 OUTER 테이블을 반드시 먼저 읽어야 하므로 조인 순서를 옵티마이저가 선택할 수 없다.

### INNER JOIN

조인은 2개의 반복문으로 두 개의 테이블을 조건에 맞게 연결해준다. (풀 테이블 스캔을 의미하는 것은 아님) 두 반복문 중 바깥쪽을 OUTER, 안쪽을 INNER라 표현한다. OUTER는 INNER보다 먼저 읽어야하고 조인에서 주도적인 역할을 하므로 드라이빙 테이블이라 한다. 이너 테이블은 끌려가는 위치이므로 드리븐 테이블이라 부른다.

```sql
FOR (record1 IN TABLE1) {
	FOR (record2 IN TABLE2) {
		IF (record1.join_column == record2.join_column) {
			join_record_found(record1.*, record2.*);
		} ELSE {
			join_record_notfound();
		}
	}
}
```

중첩된 반복문에서 최종적으로 선택될 레코드가 안쪽 반복문에 의해 결정되는 경우를 INNER JOIN이라 한다.

### OUTER JOIN

앞서 살펴본 pseudo code에서 TABLE2에 만족하는 레코드가 없는 경우 TABLE2의 컬럼을 모두 NULL로 채워 가져온다.

```sql
FOR (record1 IN TABLE1) {
	FOR (record2 IN TABLE2) {
		IF (record1.join_column == record2.join_column) {
			join_record_found(record1.*, record2.*);
		} ELSE {
			join_record_notfound(record1.*, NULL);
		}
	}
}
```

OUTER JOIN을 할 때, 레코드가 없을 수도 있는 쪽의 테이블 (이너 테이블)의 조건을 모두 LEFT JOIN의 ON 절에 명시해야 한다. 그렇지 않으면 옵티마이저는 OUTER JOIN을 내부적으로 INNER JOIN으로 변형시켜 처리할 수도 있다. LEFT OUTER JOIN의 ON 절에 명시되는 조건은 조인되는 레코드가 있을 때만 적용된다.

```sql
SELECT *
FROM employees e
	LEFT OUTER JOIN salaries s ON s.emp_no = e.emp_no
WHERE s.salary > 5000;

# 위 쿼리는 내부적으로 다음과 같이 처리된다.
SELECT *
FROM employees e
	INNER JOIN salaries s ON s.emp_no = e.emp_no
WHERE s.salary > 5000;

# 다음과 같이 수정해야 쿼리 자체의 의도나 결과를 명확히 할 수 있다.
SELECT *
FROM employees e
	LEFT OUTER JOIN salaries ON s.emp_no = e.emp_no AND s.salary > 5000;
```

### 카테시안 조인

FULL JOIN 또는 CROOS JOIN이라 한다. 조인을 수행하기 위한 테이블 간 연결 조건이 존재하지 않으면 2개 테이블의 모든 레코드로 만들 수 있는 조합을 결과로 가져오게 되는데, 이를 카테시안 조인이라 한다.

### NATURAL JOIN

두 테이블을 NATURAL JOIN하면 각 테이블의 이름이 같은 공통 컬럼을 모두 조인 조건으로 사용한다.

### 조인 버퍼를 이용한 조인

조인은 드라이빙 테이블에서 일치하는 레코드 수만큼 드리븐 테이블을 검색하면서 처리된다. 즉, 드라이빙 테이블은 한번만 읽게 되지만 드리븐 테이블은 여러 번 읽게된다. (이중 For문을 생각해보자)

만약 드리븐 테이블이 인덱스를 이용할 수 없다면 드리븐 테이블에서 연결되는 레코드를 찾기 위해 드라이빙 테이블의 레코드 수만큼 풀 테이블 스캔을 하게된다. 그래서 옵티마이저는 최대한 드리븐 테이블의 검색이 최대한 인덱스를 사용할 수 있게 실행 계획을 수립한다.

그러나 어떠한 경우에도 풀 테이블 스캔이나 인덱스 풀 스캔을 피할 수 없다면 드라이빙 테이블에서 읽은 레코드를 메모리에 캐시한 후, 드리븐 테이블과 메모리 캐시를 조인하는 형태로 처리한다. 이 때 사용되는 메모리의 캐시를 조인 버퍼라 한다.

```sql
# EX.
SELECT *
FROM dept_emp de, employees e
WHERE de.from_date > '1995-01-01' AND e.emp_no < 109004
```

조인버퍼를 사용하는 쿼리는 다음과 같이 실행 된다.

1. dept_emp 테이블의 ix_fromdate 인덱스를 이용해 `from_date > ‘1995-01-01’` 을 만족하는 레코드를 검색
2. 조인에 필요한 나머지 컬럼을 모두 dept_emp 테이블로부터 읽어 조인 버퍼에 저장
3. employees 테이블의 프라이머리 키를 이용해 `emp_no < 109004` 를 만족시키는 레코드를 검색
4. 3번에서 검색된 결과에 2번의 캐시된 조인 버퍼의 레코드를 결합해서 반환

### 조인 실행 결과는 정렬 순서를 보장하지 않는다.

일반적으로 조인으로 쿼리가 실행되는 경우 드라이빙 테이블로부터 레코드를 읽는 순서가 전체 쿼리의 결과 순서에 그대로 적용되는 것이 일반적이다.
그러나 옵티마이저의 실행 계획 선택에 따라 정렬 순서가 달라질 수 있다. 따라서 정렬이 반드시 필요하다면 명시적으로 ORDER BY를 사용하는 것이 좋다.
ORDER BY를 사용한다고 해서 무조건 정렬을 수행하는 것이 아니고, 인덱스를 적절히 활용할 수 있다면 별도의 정렬 없이 정렬된 것과 같은 결과를 낼 수도 있다. 따라서 (필요하다면) 정렬 결과를 보장하기 위해 ORDER BY 절을 사용하는 것이 권장된다.
