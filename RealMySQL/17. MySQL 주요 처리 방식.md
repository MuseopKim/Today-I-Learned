# MySQL 주요 처리 방식

## 풀 테이블 스캔

인덱스를 사용하지 않고 테이블의 데이터를 처음부터 끝까지 읽어 요청을 처리하는 방식이다. 다음과 같은 조건에 부합할 때 풀 테이블 스캔이 발생한다.

- 테이블 레코드 건수가 너무 적어서 인덱스를 읽는 것보다 풀 테이블 스캔이 더 빠른 경우
- WHERE 절, ON 절에 인덱스를 이용할 수 있는 적절한 조건이 없는 경우
- 인덱스 레인지 스캔을 이용할 수 있더라도 옵티마이저가 판단한 조건 일치 레코드 건수가 너무 많은 경우
- max_seeks_for_key 변수를 특정 값(N) 으로 설정하면 인덱스의 카디널리티, 셀렉티비티를 무시하고 최대 N건만 읽으면 된다고 판단하게 한다. 이 값을 작게 설정할수록 MySQL 서버가 인덱스를 더 사용하도록 유도한다.

  대부분의 DBMS는 풀 테이블 스캔을 실행할 때 한꺼번에 여러 개의 블록이나 페이지를 읽어오는 기능이 있고, 그 수를 조절할 수 있다. 하지만 MySQL은 풀 테이블 스캔을 실행할 때 한꺼번에 몇 개씩 페이지를 읽어올지 설정하는 변수가 없다. 그래서 MySQL은 풀 테이블 스캔을 실행할 때 디스크로부터 페이지를 하나씩만 읽어 오는 것으로 생각될때가 많은데, InnoDB 스토리지 엔진의 경우 이와 다르다.

  InnoDB 스토리지 엔진은 특정 테이블의 연속된 데이터 페이지가 읽히면 백그라운드 스레드에 의해 리드 어헤드 작업이 자동으로 시작된다.

> 리드 어헤드 - 어떤 영역의 데이터가 앞으로 필요해지리라는 것을 예측해서 요청이 오기 전 미리 디스크에서 읽어 InnoDB 버퍼 풀에 가져다 두는 것

리드 어헤드 작업으로 백그라운드 스레드가 페이지를 계속 읽으며 버퍼 풀에 저장해두면 포그라운드 스레드는 데이터를 가져다 사용한다. 이런 동작을 통해 쿼리가 빠른 속도로 처리될 수 있다.

---

## ORDER BY 처리 (Using filesort)

대부분의 SELECT 쿼리에서 정렬은 필수적으로 사용된다. 정렬을 처리하기 위해 인덱스를 이용하는 방법과 쿼리가 실행될 때 Filesort라는 별도의 처리를 이용하는 두 가지 처리 방법이 있다.

- 인덱스 이용 - INSERT, UPDATE, DELETE 쿼리가 실행될 때 인덱스가 정렬돼 있어서 순서대로 읽기만 하면 된다. 하지만 INSERT, UPDATE, DELETE 시 별도의 인덱스 추가 및 삭제 작업이 필요하며, 디스크 공간이 더 많이 필요하다.
- Filesort 이용 - 인덱스를 생성하지 않아도 되므로 인덱스를 이용할 때의 단점이 모두 커버된다. 정렬해야 할 레코드가 많지 않다면 메모리에서 Filesort가 처리 되므로 충분히 빠른 성능을 보여준다. 그러나 쿼리 실행 시 정렬이 처리되므로 레코드 수가 많다면 성능이 현저히 떨어질 수 있다.

### 소트 버퍼

MySQL은 정렬을 수행하기 위해 별도의 메모리 공간을 할당 받는데, 이 메모리 공간을 소트 버퍼라한다. 최대 사용 가능한 소트 버퍼의 공간은 sort_buffer_size라는 시스템 변수로 설정할 수 있다.

만약 정렬해야 할 레코드 수가 많다면 소트 버퍼로 할당된 공간으로는 부족하다. 이 경우 정렬 해야 할 레코드를 여러 조각으로 나누는데, 이 과정에서 임시 저장을 위해 디스크를 사용하게 된다. 각 버퍼 크기만큼만 메모리에 올려서 정렬을 수행하고, 그 결과를 디스크에 임시 저장하고, 다시 나머지 레코드를 버퍼 크기만큼 메모리에 올려 정렬하고, 디스크에 정렬 결과를 재병합하는 식으로 수행된다. 이를 멀티 머지`Multi-merge`라 표현한다.

---

## 정렬의 처리 방식

### 인덱스를 이용한 정렬

인덱스를 이용한 정렬을 위해서는 (조인 시) ORDER BY에 명시된 컬럼이 제일 먼저 읽는 테이블에 속하고, ORDER BY의 순서대로 생성된 인덱스가 있어야 한다.
또한 WHERE 절에 첫 번째 읽는 테이블의 컬럼에 대한 조건이 있다면 그 조건과 ORDER BY는 같은 같은 인덱스를 사용할 수 있어야 한다.

인덱스를 이용해 정렬이 처리되는 경우 실제 인덱스의 값이 정렬되어 있기 때문에 인덱스의 순서대로 읽기만 하면 된다.

### 드라이빙 테이블만 정렬

조인이 수행되면 결과 레코드의 수가 몇 배로 늘어난다. 그래서 조인을 실행하기 전에 첫 번째 테이블의 레코드를 먼저 정렬한 다음 조인을 실행하는 것이 좋다. 이를 위해서는 첫 번째 읽히는 테이블의 컬럼만으로 ORDER BY 절이 작성 되어야 한다.

### 임시 테이블을 이용한 정렬

쿼리가 여러 테이블을 조인하지 않고, 하나의 테이블로부터 SELECT 해서 정렬하는 경우라면 임시 테이블이 필요하지 않다. 그러나 2개 이상의 테이블을 조인하는 경우 임시 테이블이 필요할 수도 있다. 드라이빙 테이블만 정렬하는 상단의 케이스가 아니라면 항상 조인의 결과를 임시 테이블에 저장하고, 그 결과를 다시 정렬하는 과정을 거치게 된다.

---

## GROUP BY 처리

ORDER BY와 마찬가지로 쿼리가 스트리밍 처리를 할 수 없게 하는 요소다. GROUP BY는 HAVING절과 함께 사용될 수 있는데, HAVING절은 GROUP BY된 결과에 대해 필터링을 수행한다. GROUP BY에 사용된 조건은 인덱스를 사용해서 처리될 수 없으므로 HAVING절을 튜닝하려고 고민할 필요가 없다.

GROUP BY 작업이 인덱스를 사용하는 경우, 인덱스를 차례대로 이용하는 인덱스 스캔 방법과 인덱스를 건너 뛰며 읽는 루스 인덱스 스캔 두 가지 방법 중 하나로 수행된다. 인덱스를 사용하지 못하는 쿼리에서는 임시 테이블을 사용한다.

### 인덱스 스캔을 이용하는 GROUP BY(타이트 인덱스 스캔)

GROUP BY가 인덱스를 통해 처리되는 쿼리는 이미 정렬된 인덱스를 읽으면 되므로 추가적인 정렬 작업은 필요하지 않다.

### 루스 인덱스 스캔을 이용하는 GROUP BY

루스 인덱스 스캔 방식은 인덱스의 레코드를 건너뛰면서 필요한 부분만을 가져온다.

```sql
# 인덱스 - (emp_no + from_date)
SELECT emp_no
FROM salaries
WHERE from_date = '1985-03-01'
GROUP BY emp_no;
```

이 쿼리는 다음과 같은 순서로 실행된다.

1. emp_no + from_date 인덱스를 차례대로 스캔하면서 emp_no의 첫 번째 유일한 값 10001을 찾아낸다.
2. emp_no + from_date 인덱스에서 emp_no가 10001인 것 중에서 from_date 값이 1985-03-01인 레코드만 가져온다.
3. emp_no + from_date 인덱스에서 emp_no의 그 다음 유니크 값을 가져온다.
4. 앞선 단계에서 결과가 더 없으면 종료하고, 결과가 있다면 2번으로 돌아가 반복 수행한다.

### 임시 테이블을 사용하는 GROUP BY

GROUP BY의 기준 컬럼이 드라이빙 테이블에 있던, 드리븐 테이블에 있던 상관 없이 인덱스를 전혀 사용하지 못할 때는 이 방식으로 처리된다.

---

## DISTINCT 처리

특정 컬럼의 유니크한 값만을 조회하려면 쿼리에 DISTINCT를 사용해야 한다. DISTINCT는 집합 함수가 있는 경우와 없는 두 가지 경우의 적용 범위가 다르다. DISTINCT는 인덱스를 사용하지 못할 경우 항상 임시 테이블이 필요한데, Extra 컬럼에는 Using temporary가 출력되지 않는다.

### SELECT DISTINCT

셀렉트 되는 레코드 중에서 유니크한 레코드만 가져온다. 이 경우 GROUP BY와 같은 방식으로 처리가 되는데, 정렬이 보장되지 않는다.

```sql
SELECT DISTINCT emp_no FROM salaries;
```

DISTINCT는 레코드를 유니크하게 셀렉트 하는 것이지 컬럼을 유니크하게 조회하는 것이 아니다. 집합 함수 내부에서 사용된 DISTINCT가 아니라면 조회하는 컬럼의 조합이 유니크한 것들만 가져온다.

```sql
# first_name, last_name 조합이 유니크한 레코드를 조회
SELECT DISTINCT first_name, last_name FROM employees;
```
