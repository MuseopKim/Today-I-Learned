# 클러스터링 인덱스

---

클러스터링이란 주로 여러 개를 하나로 묶는다는 의미로 사용 된다. 인덱스에서의 클러스터링은 값이 비슷한 것들을 묶어 저장하는 형태로 구현된다. 이는 주로 비슷한 값들을 동시에 조회하는 케이스가 많다는 점에 착안되었다. MySQL에서 클러스터링 인덱스는 InnoDB와 TokuDB 스토리지 엔진에서만 지원한다.

---

### 클러스터링 인덱스

클러스터링 인덱스는 테이블의 프라이머리 키에 대해서만 적용된다. 즉, 프라이머리 키가 비슷한 레코드끼리 묶어서 저장하는 것을 클러스터링 인덱스라 한다. 프라이머리 키값에 의해 레코드의 저장 위치가 결정되는 것이다. 즉 프라이머리 키 값이 변경되면 저장되는 위치가 바뀌는 것을 의미하는데, 프라이머리 키 값으로 클러스터링된 테이블은 프라이머리 키 값 자체에 대한 의존도가 크기 때문에 프라이머리 키를 신중히 결정해야 한다.

클러스터링 인덱스는 프라이머리 키 값에 의해 레코드의 저장 위치가 결정되기 때문에 인덱스 알고리즘이라기 보다는 테이블 레코드의 저장방식이라 할 수 있다. 그래서 '클러스터링 인덱스', '클러스터 테이블'은 사실상 동의어이다. 클러스터링의 기준인 프라이머리 키를 '클러스터 키' 라고도 표현한다.

InnoDB와 같이 클러스터링 인덱스 기반으로 저장하는 테이블은 프라이머리 키 기반의 검색이 매우 빠르고 레코드의 저장이나 프라이머리 키 변경이 상대적으로 느리다.

클러스터링 인덱스의 구조는 B-Tree와 많이 닮았다. 하지만 클러스터링 인덱스의 리프 노드에는 모든 컬럼이 같이 저장 된다는 것이 다르다. 즉, 클러스터링 테이블은 그 자체가 하나의 거대한 인덱스 구조로 관리된다.

### 프라이머리 키가 없는 InnoDB 테이블

프라이머리 키가 없는 경우 InnoDB 스토리지 엔진이 다음의 우선순위대로 프라이머리 키를 대체할 컬럼을 선택한다.

1. 프라이머리 키가 있으면 기본적으로 프라이머리 키를 클러스터 키로 선택
2. NOT NULL 옵션의 유니크 인덱스 중에서 첫 번째 인덱스를 클러스터 키로 선택
3. 자동으로 유니크한 값을 가지도록 증가되는 컬럼을 내부적으로 추가한 후 클러스터 키를 선택

InnoDB 스토리지 엔진이 적절한 클러스터 키 후보를 찾지 못해서 내부적으로 자동 증가 컬럼을 추가한 경우, 자동으로 추가된 컬럼은 사용자에게 노출되지 않으며 쿼리에서도 사용할 수 없다.

---

## 보조 인덱스에 미치는 영향

MyISAM이나 MEMORY 테이블과 같이 클러스터링 되지 않은 테이블은 INSERT될 때 한번 저장된 공간에서 절대 이동하지 않는다. 이 때 데이터 레코드가 저장된 주소는 내부적인 레코드 아이디 역할을 한다. 그리고 프라이머리 키나 보조 인덱스의 각 키는 그 주소를 이용해 실제 데이터 레코드를 찾아온다.

InnoDB에서는 보조 인덱스에 레코드의 저장 주소가 아닌 프라이머리 키 값을 저장하도록 구현되어 있다. 따라서 보조 인덱스를 통한 조회는 다음의 절차로 수행된다.

1. 보조 인덱스를 검색해 레코드의 프라이머리 키를 확인
2. 프라이머리 키 값을 이용해 다시 한번 테이블을 검색한 후 최종 레코드를 반환

---

## 클러스터 인덱스의 장점과 단점

### 장점

- 프라이머리 키로 검색할 때 처리 성능이 매우 빠른데, 프라이머리 키를 범위 검색하는 경우 특히 빠르다.
- 커버링 인덱스 - 테이블의 모든 보조 인덱스가 프라이머리 키를 가지고 있기 때문에 인덱스만으로 처리될 수 있는 경우가 많다.

### 단점

- 테이블의 모든 보조 인덱스가 클러스터 키를 갖기 때문에 클러스터 키 값이 클 경우 전체적으로 인덱스의 크기가 커진다.
- 보조 인덱스를 통해 검색할 때 프라이머리 키로 다시 한번 검색해야 하므로 처리 성능이 조금 떨어진다.
- INSERT 할 때 프라이머리 키에 의해 레코드의 저장 위치가 결정되기 때문에 처리 성능이 느리다.
- 프라이머리 키를 변경할 때 레코드를 DELETE하고 INSERT하는 작업이 필요해서 처리 성능이 느리다.

---
