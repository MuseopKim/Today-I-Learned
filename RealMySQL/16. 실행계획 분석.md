# 실행계획 분석

MySQL 쿼리의 실행 계획을 확인하려면 `EXPLAIN` 명령을 사용하면 된다. 또한 `EXPLAIN EXTENDED`, `EXPLAIN PARTITIONS` 명령을 이용해 더 상세한 실행 계획을 확인할 수 있다.

```sql
EXPLAIN
SELECT e.emp_no, e.first_name, s.from_date, s.salary
FROM employees e, salaries s
WHERE e.emp_no = s.emp_no
LIMIT 10;
```

EXPLAIN을 실행하면 쿼리 문장에서 사용된 테이블의 개수만큼(서브 쿼리로 임시 테이블을 생성한 경우 그 테이블까지 포함) 레코드가 출력된다. 출력된 실행 계획에서 위쪽에 출력된 결과일수록 쿼리의 바깥 부분이거나 먼저 접근한 테이블이고, 아래쪽에 출력된 결과일수록 쿼리의 안쪽 부분 또는 나중에 접근한 테이블에 해당된다.

---

## id

하나의 SELECT 문장은 다시 하나 이상의 하위 SELECT 문장을 포함할 수 있다.

```sql
SELECT
FROM (SELECT ... FROM tb_test1) tb1,
			tb_test2 tb2
WHERE tb1.id = tb2.id
```

실행 계획에서 가장 왼쪽에 표시되는 id 컬럼은 단위 SELECT 쿼리별로 부여되는 식별자 값이다. 위 예제의 경우 최소 2개의 식별자가 부여된다.

조인의 경우 하나의 SELECT 문장에서 조인되는 테이블 개수만큼 실행 계획 레코드가 출력되지만 같은 id가 부여된다.

---

## select_type

각 단위 SELECT 쿼리가 어떤 타입의 쿼리인지 표시되는 컬럼

### SIMPLE

UNION이나 서브 쿼리를 사용하지 않는 단순한 SELECT 쿼리인 경우. 쿼리 문장이 아무리 복잡하더라도 select_type이 SIMPLE인 단위 쿼리는 반드시 하나만 존재한다.

### PRIMARY

UNION이나 서브 쿼리가 포함된 SELECT 쿼리의 실행 계획에서 가장 바깥쪽에 있는 단위 쿼리. 하나의 SELECT 문에는 select_type이 PRIMARY인 쿼리는 하나만 존재한다.

### UNION

SELECT 쿼리 가운데 첫 번째를 제외한 두 번째 이후 단위 SELECT 쿼리의 select_type이다. UNION의 첫 번째 단위 SELECT는 select_type이 UNION이 아닌 UNION 쿼리로 결합 된 전체 집합의 select_type이 표시된다.

### DEPENDENT UNION

UNION select_type과 같이 쿼리에 UNION이나 UNION ALL로 집합을 결합하는 쿼리에 표시된다. 한 가지 다른 점은 단위 쿼리가 외부의 의해 영향을 받는 것이다. (외부에 정의된 테이블의 컬럼을 사용)

### UNION RESULT

UNION 결과를 담아두는 테이블. UNION ALL이나 UNION (DISTINCT) 쿼리는 모두 UNION의 결과를 임시 테이블로 생성한다. 실행 계획상에서 이 임시 테이블을 가리키는 라인의 select_type이 UNION RESULT다. UNION RESULT는 실제 쿼리에서 단위 쿼리가 아니기 때문에 별도의 id 값은 부여되지 않는다.

### SUBQUERY

일반적으로 서브 쿼리라 하면 여러 가지를 통틀어 이야기하는데, 여기서 SUBQUERY라 하는 것은 FROM 절 이외에서 사용되는 서브 쿼리만을 의미한다.

**서브 쿼리의 종류**

- 네스티드 쿼리 : SELECT 컬럼에 사용되는 서브 쿼리
- 서브 쿼리 : WHERE절에 사용되는 경우 그냥 서브 쿼리라 한다.
- 파생 테이블 : FROM절에 사용된 서브 쿼리를 MySQL에서는 파생 테이블이라 하며, 일반적으로 인라인 뷰 또는 서브 셀렉트라 부른다.
- 스칼라 서브 쿼리 : 하나의 값만 반환하는 쿼리
- 로우 서브 쿼리 : 컬럼의 개수에 관계없이 하나의 레코드만 반환하는 쿼리

### DEPENDENT SUBQUERY

서브 쿼리가 바깥쪽 SELECT 쿼리에서 정의된 컬럼을 사용하는 경우 select_type이 `DEPENDENT SUBQUERY` 가 된다. 외부가 먼저 수행된 후 내부 쿼리가 실행돼야 하므로 일반 서브 쿼리보다는 처리 속도가 느리다.

### DERIVED

서브 쿼리가 FROM절에 사용된 경우 MySQL은 항상 select_type이 DERIVED인 실행 계획을 만든다. DERIVED는 단위 SELECT 쿼리의 실행 결과를 메모리나 디스크에 임시 테이블을 생성하는 것을 의미한다. 파생 테이블에는 인덱스가 전혀 없으므로 다른 테이블과 조인할 때 성능상 불리할 때가 많다.

### UNCACHEABLE SUBQUERY

하나의 쿼리 문장에서 서브 쿼리가 하나만 있어라도 실제 그 서브 쿼리가 한번만 실행되는 것은 아니다. 그런데 조건이 똑같은 서브 쿼리가 실행될 때는 다시 실행하지 않고 이전의 실행 결과를 그대로 사용할 수 있게 내부적인 캐시 공간에 담아둔다. `UNCACHEABLE SUBQUERY` 는 캐시를 사용할 수 없는 서브 쿼리를 말하는데, 다음과 같은 조건에서 발생한다.

- 사용자 변수가 서브 쿼리에 사용 된 경우
- NOT_DETERMINISTIC 속성의 스토어드 루틴이 서브 쿼리 내에서 사용된 경우
- UUID, RAND()와 같이 결과값이 호출될 때마다 값이 달라지는 함수가 서브 쿼리에 사용된 경우

### UNCACHEABLE UNION

UNCACHABLE UNION이란 `UNION` + `UNCACHEABLE` 두 개의 키워드의 속성이 혼합된 select_type이다.

---

## table 컬럼

MySQL의 실행 계획은 단위 SELECT 기준이 아닌 테이블 기준으로 표시된다. 만약 테이블 이름에 별칭이 부여된 경우 별칭이 표시된다.

또한 <>로 둘러싸인 이름이 명시되는 경우가 많은데, 이는 임시 테이블을 의미한다. 또한 <> 안에 항상 표시되는 숫자는 단위 SELECT쿼리의 id를 지칭한다. (ex. `<derived 2>` - SELECT 쿼리의 아이디가 2번인 실행 계획으로 부터 파생된 임시 테이블)

---

## type 컬럼

쿼리 실행 계획에서 type 컬럼 이후의 컬럼들은 MySQL 서버가 각 테이블의 레코드를 어떤 방식으로 읽었는지를(테이블을 끝까지 읽는 풀 테이블 스캔, 인덱스를 사용해 레코드를 읽는지 여부) 의미한다.

인덱스의 효율적 활용을 확인하는 지표이기도 해서 일반적으로 쿼리를 튜닝할 때 반드시 체크해야 항목이다.

풀 테이블 스캔을 의미하는 `ALL` 타입을 제외한 모든 타입은 인덱스를 사용하는 접근 방법이다. 또한 `index_merge` 를 제외한 나머지 접근 방법은 반드시 하나의 인덱스만 사용한다.

### system

레코드가 한 건만 존재하는 테이블 또는 한 건도 존재하지 않는 테이블을 참조하는 형태의 접근 방법이다. InnoDB 테이블에서는 나타나지 않고 MyISAM, MEMORY 테이블에서만 사용되는 접근 방법이다.

### const

테이블의 레코드 건수에 관계없이 쿼리가 프라이머리 키나 유니크 키 컬럼을 사용하는 WHERE 조건절을 가지고 있으며, 반드시 1건을 반환하는 쿼리 처리 방식이다. MySQL의 옵티마이저가 쿼리를 최적화 하는 단계에서 모두 상수화한다.

### eq_ref

여러 테이블이 조인되는 쿼리의 실행 계획에서만 표시된다. 조인에서 처음 읽은 테이블의 컬럼 값을 그 다음 읽어야 할 테이블의 프라이머리 키나 유니크 키 컬럼의 검색 조건에 사용 할 때를 eq_ref라 한다. 또한 두 번째 이후에 읽히는 테이블에서 다중 컬럼으로 만들어진 PK나 유니크 인덱스가 있을 경우, 인덱스의 모든 컬럼이 비교 조건에 사용 되어야만 eq_ref 접근 방법이 사용될 수 있다.

### ref

eq_ref와 달리 조인의 순서와 관계없이 사용되며, 프라이머리 키나 유니크 키 등의 제약 조건도 없다. 인덱스의 종류와 관계없이 동등 조건으로 검색할 때 사용된다.

### fulltext

전문 검색 인덱스를 사용해 레코드를 읽는 접근 방법을 의미한다.

### ref_or_null

접근 방법은 ref 방식과 같은데, NULL 비교가 추가된 형태. 이름 그대로 ref 방식 또는 IS NULL 접근 방식을 의미한다.

### unique_subquery

WHERE 조건에서 사용될 수 있는 IN 형태의 쿼리를 위한 접근 방식. 서브 쿼리에서 중복되지 않은 유니크한 값만 반환할 때 이 접근 방법을 사용한다.

### index_subquery

IN 연산자의 특성상 IN 또는 IN 형태의 조건은 괄호 안에 있는 값의 목록에서 중복된 값이 먼저 제거돼야 한다. IN에서 subquery가 중복된 값을 반환할 수는 있지만 중복된 값을 인덱스를 이용해 제거할 수 있을 때 index_subquery 접근 방법이 사용된다.

### range

인덱스 레인지 스캔 형태의 접근 방법이다. range는 인덱스를 하나의 값이 아닌 범위로 검색하는 경우를 의미하는데, <>, IS NULL, BETWEEN, IN, LIKE 등의 연산자를 이용해 인덱스를 검색할 때 사용된다.

### index_merge

2개 이상의 인덱스를 이용해 각각의 검색 결과를 만들어낸 후 그 결과를 병합 처리하는 방식. 다음과 같은 특징이 있다.

- 여러 인덱스를 읽어야 하므로 일반적으로 range 접근 방식보다 효율성이 떨어진다.
- AND, OR 연산이 복잡하게 연결된 쿼리에서는 제대로 최적화되지 못할 때가 많다.
- 전문 검색 인덱스를 사용하는 쿼리에서는 index_merge가 적용되지 않는다.
- index_merge 접근 방식으로 처리된 결과는 항상 2개 이상의 집합이 된다. 따라서 그 두 집합의 교집합, 차집합 또는 중복 제거와 같은 부가적인 작업이 더 필요하다.

### index

index 접근 방식은 인덱스를 처음부터 끝까지 다 읽는 인덱스 풀 스캔을 의미한다. range 접근 방식과 같이 인덱스를 효율적으로 사용하는걸 의미하는 것이 아니다.

index 접근 방법은 1, 2번 조건을 충족하는 1, 3번 조건을 충족하는 쿼리에서 사용되는 읽기 방식이다.

- range, const, ref와 같은 접근 방식으로 인덱스를 사용하지 못하는 경우
- 인덱스에 포함된 컬럼만으로 처리할 수 있는 쿼리
- 인덱스를 이용해 정렬이나 그룹핑 작업이 가능한 경우

### ALL

풀 테이블 스캔을 의미하는 접근 방식. 테이블을 처음부터 끝까지 전부 읽고 불필요한 레코드를 제거한 뒤 반환한다. InnoDB는 풀 테이블 스캔이나 인덱스 풀 스캔과 같은 대량의 디스크 I/O를 유발하는 작업을 위해 한꺼번에 많은 페이지를 읽어 들이는 기능을 제공한다. InnoDB에서는 이를 `리드 어헤드` 라 한다.

배치 프로그램처럼 대용량의 레코드를 처리하는 쿼리에서는 잘못 튜닝된 쿼리보다 훨씬 나은 접근 방법이 되기도 한다.

---

## possible_keys

MySQL 옵티마이저는 쿼리를 처리하기 위해 여러가지 처리 방법을 고려하고 그 중 비용이 가장 낮을 것으로 예상되는 방법을 선택한다. possible_keys는 단지 옵티마이저가 최적의 실행 계획을 세우는 과정에서 후보로 선정했던 인덱스 목록일 뿐이다.

---

## key

Key 컬럼에 표시되는 인덱스는 최종 선택된 실행 계획에서 사용되는 인덱스이다. PRIMARY인 경우 프라이머리 키를 사용한다는 의미이고, 나머지 값들은 모두 테이블이나 인덱스를 생성할 때 부여했던 고유 값이다.

---

## key_len

매우 중요한 정보 중 하나인데, 실무에서 사용하는 테이블은 다중 인덱스가 더 많다. 이 값은 쿼리를 처리하기 위해 다중 컬럼으로 구성된 인덱스에서 몇 개의 컬럼까지 사용했는지를 알려준다. (바이트로 표기)

---

## ref

ref 방식은 참조 조건 (Equal 비교 조건)으로 어떤 값이 제공 됐는지 보여준다. 만약 상수 값으로 지정했다면 const, 다른 테이블의 컬럼 값이면 그 테이블 명과 컬럼 명이 표시된다.

만약 참조 조건에 대한 값을 함수나 연산을 통해 명시적으로 변경할 경우, `func` 가 표시된다. 또한 다른 컬럼의 타입으로 조인할 때에도 MySQL 내부적으로 변환하는 과정을 거치게 된다.

---

## rows

MySQL 옵티마이저가 실행계획을 수립할 때 해당 쿼리에서 얼마나 많은 레코드를 읽고 비교해야 하는지 통계를 내고 예측하여 많은 실행 계획중 하나를 선택하게 된다. 대상 테이블의 레코드 또는 인덱스 값의 분포도가 어떤지를 통계 정보를 기준으로 조사하는 것이다.

rows 컬럼은 옵티마이저가 실행 계획의 효율성을 고려하는 과정에서 예측했던 처리 할 레코드의 수다.

---
