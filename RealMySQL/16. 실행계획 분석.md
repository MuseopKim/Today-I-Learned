# 실행계획 분석

MySQL 쿼리의 실행 계획을 확인하려면 `EXPLAIN` 명령을 사용하면 된다. 또한 `EXPLAIN EXTENDED`, `EXPLAIN PARTITIONS` 명령을 이용해 더 상세한 실행 계획을 확인할 수 있다.

```sql
EXPLAIN
SELECT e.emp_no, e.first_name, s.from_date, s.salary
FROM employees e, salaries s
WHERE e.emp_no = s.emp_no
LIMIT 10;
```

EXPLAIN을 실행하면 쿼리 문장에서 사용된 테이블의 개수만큼(서브 쿼리로 임시 테이블을 생성한 경우 그 테이블까지 포함) 레코드가 출력된다. 출력된 실행 계획에서 위쪽에 출력된 결과일수록 쿼리의 바깥 부분이거나 먼저 접근한 테이블이고, 아래쪽에 출력된 결과일수록 쿼리의 안쪽 부분 또는 나중에 접근한 테이블에 해당된다.

---

## id

하나의 SELECT 문장은 다시 하나 이상의 하위 SELECT 문장을 포함할 수 있다.

```sql
SELECT
FROM (SELECT ... FROM tb_test1) tb1,
			tb_test2 tb2
WHERE tb1.id = tb2.id
```

실행 계획에서 가장 왼쪽에 표시되는 id 컬럼은 단위 SELECT 쿼리별로 부여되는 식별자 값이다. 위 예제의 경우 최소 2개의 식별자가 부여된다.

조인의 경우 하나의 SELECT 문장에서 조인되는 테이블 개수만큼 실행 계획 레코드가 출력되지만 같은 id가 부여된다.

---

## select_type

각 단위 SELECT 쿼리가 어떤 타입의 쿼리인지 표시되는 컬럼

### SIMPLE

UNION이나 서브 쿼리를 사용하지 않는 단순한 SELECT 쿼리인 경우. 쿼리 문장이 아무리 복잡하더라도 select_type이 SIMPLE인 단위 쿼리는 반드시 하나만 존재한다.

### PRIMARY

UNION이나 서브 쿼리가 포함된 SELECT 쿼리의 실행 계획에서 가장 바깥쪽에 있는 단위 쿼리. 하나의 SELECT 문에는 select_type이 PRIMARY인 쿼리는 하나만 존재한다.

### UNION

SELECT 쿼리 가운데 첫 번째를 제외한 두 번째 이후 단위 SELECT 쿼리의 select_type이다. UNION의 첫 번째 단위 SELECT는 select_type이 UNION이 아닌 UNION 쿼리로 결합 된 전체 집합의 select_type이 표시된다.

### DEPENDENT UNION

UNION select_type과 같이 쿼리에 UNION이나 UNION ALL로 집합을 결합하는 쿼리에 표시된다. 한 가지 다른 점은 단위 쿼리가 외부의 의해 영향을 받는 것이다. (외부에 정의된 테이블의 컬럼을 사용)

### UNION RESULT

UNION 결과를 담아두는 테이블. UNION ALL이나 UNION (DISTINCT) 쿼리는 모두 UNION의 결과를 임시 테이블로 생성한다. 실행 계획상에서 이 임시 테이블을 가리키는 라인의 select_type이 UNION RESULT다. UNION RESULT는 실제 쿼리에서 단위 쿼리가 아니기 때문에 별도의 id 값은 부여되지 않는다.

### SUBQUERY

일반적으로 서브 쿼리라 하면 여러 가지를 통틀어 이야기하는데, 여기서 SUBQUERY라 하는 것은 FROM 절 이외에서 사용되는 서브 쿼리만을 의미한다.

**서브 쿼리의 종류**

- 네스티드 쿼리 : SELECT 컬럼에 사용되는 서브 쿼리
- 서브 쿼리 : WHERE절에 사용되는 경우 그냥 서브 쿼리라 한다.
- 파생 테이블 : FROM절에 사용된 서브 쿼리를 MySQL에서는 파생 테이블이라 하며, 일반적으로 인라인 뷰 또는 서브 셀렉트라 부른다.
- 스칼라 서브 쿼리 : 하나의 값만 반환하는 쿼리
- 로우 서브 쿼리 : 컬럼의 개수에 관계없이 하나의 레코드만 반환하는 쿼리

### DEPENDENT SUBQUERY

서브 쿼리가 바깥쪽 SELECT 쿼리에서 정의된 컬럼을 사용하는 경우 select_type이 `DEPENDENT SUBQUERY` 가 된다. 외부가 먼저 수행된 후 내부 쿼리가 실행돼야 하므로 일반 서브 쿼리보다는 처리 속도가 느리다.

### DERIVED

서브 쿼리가 FROM절에 사용된 경우 MySQL은 항상 select_type이 DERIVED인 실행 계획을 만든다. DERIVED는 단위 SELECT 쿼리의 실행 결과를 메모리나 디스크에 임시 테이블을 생성하는 것을 의미한다. 파생 테이블에는 인덱스가 전혀 없으므로 다른 테이블과 조인할 때 성능상 불리할 때가 많다.

### UNCACHEABLE SUBQUERY

하나의 쿼리 문장에서 서브 쿼리가 하나만 있어라도 실제 그 서브 쿼리가 한번만 실행되는 것은 아니다. 그런데 조건이 똑같은 서브 쿼리가 실행될 때는 다시 실행하지 않고 이전의 실행 결과를 그대로 사용할 수 있게 내부적인 캐시 공간에 담아둔다. `UNCACHEABLE SUBQUERY` 는 캐시를 사용할 수 없는 서브 쿼리를 말하는데, 다음과 같은 조건에서 발생한다.

- 사용자 변수가 서브 쿼리에 사용 된 경우
- NOT_DETERMINISTIC 속성의 스토어드 루틴이 서브 쿼리 내에서 사용된 경우
- UUID, RAND()와 같이 결과값이 호출될 때마다 값이 달라지는 함수가 서브 쿼리에 사용된 경우

### UNCACHEABLE UNION

UNCACHABLE UNION이란 `UNION` + `UNCACHEABLE` 두 개의 키워드의 속성이 혼합된 select_type이다.

---
