# 실행계획 분석

MySQL 쿼리의 실행 계획을 확인하려면 `EXPLAIN` 명령을 사용하면 된다. 또한 `EXPLAIN EXTENDED`, `EXPLAIN PARTITIONS` 명령을 이용해 더 상세한 실행 계획을 확인할 수 있다.

```sql
EXPLAIN
SELECT e.emp_no, e.first_name, s.from_date, s.salary
FROM employees e, salaries s
WHERE e.emp_no = s.emp_no
LIMIT 10;
```

EXPLAIN을 실행하면 쿼리 문장에서 사용된 테이블의 개수만큼(서브 쿼리로 임시 테이블을 생성한 경우 그 테이블까지 포함) 레코드가 출력된다. 출력된 실행 계획에서 위쪽에 출력된 결과일수록 쿼리의 바깥 부분이거나 먼저 접근한 테이블이고, 아래쪽에 출력된 결과일수록 쿼리의 안쪽 부분 또는 나중에 접근한 테이블에 해당된다.

---

## id

하나의 SELECT 문장은 다시 하나 이상의 하위 SELECT 문장을 포함할 수 있다.

```sql
SELECT
FROM (SELECT ... FROM tb_test1) tb1,
			tb_test2 tb2
WHERE tb1.id = tb2.id
```

실행 계획에서 가장 왼쪽에 표시되는 id 컬럼은 단위 SELECT 쿼리별로 부여되는 식별자 값이다. 위 예제의 경우 최소 2개의 식별자가 부여된다.

조인의 경우 하나의 SELECT 문장에서 조인되는 테이블 개수만큼 실행 계획 레코드가 출력되지만 같은 id가 부여된다.

---

## select_type

각 단위 SELECT 쿼리가 어떤 타입의 쿼리인지 표시되는 컬럼

### SIMPLE

UNION이나 서브 쿼리를 사용하지 않는 단순한 SELECT 쿼리인 경우. 쿼리 문장이 아무리 복잡하더라도 select_type이 SIMPLE인 단위 쿼리는 반드시 하나만 존재한다.

### PRIMARY

UNION이나 서브 쿼리가 포함된 SELECT 쿼리의 실행 계획에서 가장 바깥쪽에 있는 단위 쿼리. 하나의 SELECT 문에는 select_type이 PRIMARY인 쿼리는 하나만 존재한다.

### UNION

SELECT 쿼리 가운데 첫 번째를 제외한 두 번째 이후 단위 SELECT 쿼리의 select_type이다. UNION의 첫 번째 단위 SELECT는 select_type이 UNION이 아닌 UNION 쿼리로 결합 된 전체 집합의 select_type이 표시된다.

### DEPENDENT UNION

UNION select_type과 같이 쿼리에 UNION이나 UNION ALL로 집합을 결합하는 쿼리에 표시된다. 한 가지 다른 점은 단위 쿼리가 외부의 의해 영향을 받는 것이다. (외부에 정의된 테이블의 컬럼을 사용)

### UNION RESULT

UNION 결과를 담아두는 테이블. UNION ALL이나 UNION (DISTINCT) 쿼리는 모두 UNION의 결과를 임시 테이블로 생성한다. 실행 계획상에서 이 임시 테이블을 가리키는 라인의 select_type이 UNION RESULT다. UNION RESULT는 실제 쿼리에서 단위 쿼리가 아니기 때문에 별도의 id 값은 부여되지 않는다.

### SUBQUERY

일반적으로 서브 쿼리라 하면 여러 가지를 통틀어 이야기하는데, 여기서 SUBQUERY라 하는 것은 FROM 절 이외에서 사용되는 서브 쿼리만을 의미한다.

**서브 쿼리의 종류**

- 네스티드 쿼리 : SELECT 컬럼에 사용되는 서브 쿼리
- 서브 쿼리 : WHERE절에 사용되는 경우 그냥 서브 쿼리라 한다.
- 파생 테이블 : FROM절에 사용된 서브 쿼리를 MySQL에서는 파생 테이블이라 하며, 일반적으로 인라인 뷰 또는 서브 셀렉트라 부른다.
- 스칼라 서브 쿼리 : 하나의 값만 반환하는 쿼리
- 로우 서브 쿼리 : 컬럼의 개수에 관계없이 하나의 레코드만 반환하는 쿼리

### DEPENDENT SUBQUERY

서브 쿼리가 바깥쪽 SELECT 쿼리에서 정의된 컬럼을 사용하는 경우 select_type이 `DEPENDENT SUBQUERY` 가 된다. 외부가 먼저 수행된 후 내부 쿼리가 실행돼야 하므로 일반 서브 쿼리보다는 처리 속도가 느리다.

### DERIVED

서브 쿼리가 FROM절에 사용된 경우 MySQL은 항상 select_type이 DERIVED인 실행 계획을 만든다. DERIVED는 단위 SELECT 쿼리의 실행 결과를 메모리나 디스크에 임시 테이블을 생성하는 것을 의미한다. 파생 테이블에는 인덱스가 전혀 없으므로 다른 테이블과 조인할 때 성능상 불리할 때가 많다.

### UNCACHEABLE SUBQUERY

하나의 쿼리 문장에서 서브 쿼리가 하나만 있어라도 실제 그 서브 쿼리가 한번만 실행되는 것은 아니다. 그런데 조건이 똑같은 서브 쿼리가 실행될 때는 다시 실행하지 않고 이전의 실행 결과를 그대로 사용할 수 있게 내부적인 캐시 공간에 담아둔다. `UNCACHEABLE SUBQUERY` 는 캐시를 사용할 수 없는 서브 쿼리를 말하는데, 다음과 같은 조건에서 발생한다.

- 사용자 변수가 서브 쿼리에 사용 된 경우
- NOT_DETERMINISTIC 속성의 스토어드 루틴이 서브 쿼리 내에서 사용된 경우
- UUID, RAND()와 같이 결과값이 호출될 때마다 값이 달라지는 함수가 서브 쿼리에 사용된 경우

### UNCACHEABLE UNION

UNCACHABLE UNION이란 `UNION` + `UNCACHEABLE` 두 개의 키워드의 속성이 혼합된 select_type이다.

---

## table 컬럼

MySQL의 실행 계획은 단위 SELECT 기준이 아닌 테이블 기준으로 표시된다. 만약 테이블 이름에 별칭이 부여된 경우 별칭이 표시된다.

또한 <>로 둘러싸인 이름이 명시되는 경우가 많은데, 이는 임시 테이블을 의미한다. 또한 <> 안에 항상 표시되는 숫자는 단위 SELECT쿼리의 id를 지칭한다. (ex. `<derived 2>` - SELECT 쿼리의 아이디가 2번인 실행 계획으로 부터 파생된 임시 테이블)

---

## type 컬럼

쿼리 실행 계획에서 type 컬럼 이후의 컬럼들은 MySQL 서버가 각 테이블의 레코드를 어떤 방식으로 읽었는지를(테이블을 끝까지 읽는 풀 테이블 스캔, 인덱스를 사용해 레코드를 읽는지 여부) 의미한다.

인덱스의 효율적 활용을 확인하는 지표이기도 해서 일반적으로 쿼리를 튜닝할 때 반드시 체크해야 항목이다.

풀 테이블 스캔을 의미하는 `ALL` 타입을 제외한 모든 타입은 인덱스를 사용하는 접근 방법이다. 또한 `index_merge` 를 제외한 나머지 접근 방법은 반드시 하나의 인덱스만 사용한다.

### system

레코드가 한 건만 존재하는 테이블 또는 한 건도 존재하지 않는 테이블을 참조하는 형태의 접근 방법이다. InnoDB 테이블에서는 나타나지 않고 MyISAM, MEMORY 테이블에서만 사용되는 접근 방법이다.

### const

테이블의 레코드 건수에 관계없이 쿼리가 프라이머리 키나 유니크 키 컬럼을 사용하는 WHERE 조건절을 가지고 있으며, 반드시 1건을 반환하는 쿼리 처리 방식이다. MySQL의 옵티마이저가 쿼리를 최적화 하는 단계에서 모두 상수화한다.

### eq_ref

여러 테이블이 조인되는 쿼리의 실행 계획에서만 표시된다. 조인에서 처음 읽은 테이블의 컬럼 값을 그 다음 읽어야 할 테이블의 프라이머리 키나 유니크 키 컬럼의 검색 조건에 사용 할 때를 eq_ref라 한다. 또한 두 번째 이후에 읽히는 테이블에서 다중 컬럼으로 만들어진 PK나 유니크 인덱스가 있을 경우, 인덱스의 모든 컬럼이 비교 조건에 사용 되어야만 eq_ref 접근 방법이 사용될 수 있다.

### ref

eq_ref와 달리 조인의 순서와 관계없이 사용되며, 프라이머리 키나 유니크 키 등의 제약 조건도 없다. 인덱스의 종류와 관계없이 동등 조건으로 검색할 때 사용된다.

### fulltext

전문 검색 인덱스를 사용해 레코드를 읽는 접근 방법을 의미한다.

### ref_or_null

접근 방법은 ref 방식과 같은데, NULL 비교가 추가된 형태. 이름 그대로 ref 방식 또는 IS NULL 접근 방식을 의미한다.

### unique_subquery

WHERE 조건에서 사용될 수 있는 IN 형태의 쿼리를 위한 접근 방식. 서브 쿼리에서 중복되지 않은 유니크한 값만 반환할 때 이 접근 방법을 사용한다.

### index_subquery

IN 연산자의 특성상 IN 또는 IN 형태의 조건은 괄호 안에 있는 값의 목록에서 중복된 값이 먼저 제거돼야 한다. IN에서 subquery가 중복된 값을 반환할 수는 있지만 중복된 값을 인덱스를 이용해 제거할 수 있을 때 index_subquery 접근 방법이 사용된다.

### range

인덱스 레인지 스캔 형태의 접근 방법이다. range는 인덱스를 하나의 값이 아닌 범위로 검색하는 경우를 의미하는데, <>, IS NULL, BETWEEN, IN, LIKE 등의 연산자를 이용해 인덱스를 검색할 때 사용된다.

### index_merge

2개 이상의 인덱스를 이용해 각각의 검색 결과를 만들어낸 후 그 결과를 병합 처리하는 방식. 다음과 같은 특징이 있다.

- 여러 인덱스를 읽어야 하므로 일반적으로 range 접근 방식보다 효율성이 떨어진다.
- AND, OR 연산이 복잡하게 연결된 쿼리에서는 제대로 최적화되지 못할 때가 많다.
- 전문 검색 인덱스를 사용하는 쿼리에서는 index_merge가 적용되지 않는다.
- index_merge 접근 방식으로 처리된 결과는 항상 2개 이상의 집합이 된다. 따라서 그 두 집합의 교집합, 차집합 또는 중복 제거와 같은 부가적인 작업이 더 필요하다.

### index

index 접근 방식은 인덱스를 처음부터 끝까지 다 읽는 인덱스 풀 스캔을 의미한다. range 접근 방식과 같이 인덱스를 효율적으로 사용하는걸 의미하는 것이 아니다.

index 접근 방법은 1, 2번 조건을 충족하는 1, 3번 조건을 충족하는 쿼리에서 사용되는 읽기 방식이다.

- range, const, ref와 같은 접근 방식으로 인덱스를 사용하지 못하는 경우
- 인덱스에 포함된 컬럼만으로 처리할 수 있는 쿼리
- 인덱스를 이용해 정렬이나 그룹핑 작업이 가능한 경우

### ALL

풀 테이블 스캔을 의미하는 접근 방식. 테이블을 처음부터 끝까지 전부 읽고 불필요한 레코드를 제거한 뒤 반환한다. InnoDB는 풀 테이블 스캔이나 인덱스 풀 스캔과 같은 대량의 디스크 I/O를 유발하는 작업을 위해 한꺼번에 많은 페이지를 읽어 들이는 기능을 제공한다. InnoDB에서는 이를 `리드 어헤드` 라 한다.

배치 프로그램처럼 대용량의 레코드를 처리하는 쿼리에서는 잘못 튜닝된 쿼리보다 훨씬 나은 접근 방법이 되기도 한다.

---

## possible_keys

MySQL 옵티마이저는 쿼리를 처리하기 위해 여러가지 처리 방법을 고려하고 그 중 비용이 가장 낮을 것으로 예상되는 방법을 선택한다. possible_keys는 단지 옵티마이저가 최적의 실행 계획을 세우는 과정에서 후보로 선정했던 인덱스 목록일 뿐이다.

---

## key

Key 컬럼에 표시되는 인덱스는 최종 선택된 실행 계획에서 사용되는 인덱스이다. PRIMARY인 경우 프라이머리 키를 사용한다는 의미이고, 나머지 값들은 모두 테이블이나 인덱스를 생성할 때 부여했던 고유 값이다.

---

## key_len

매우 중요한 정보 중 하나인데, 실무에서 사용하는 테이블은 다중 인덱스가 더 많다. 이 값은 쿼리를 처리하기 위해 다중 컬럼으로 구성된 인덱스에서 몇 개의 컬럼까지 사용했는지를 알려준다. (바이트로 표기)

---

## ref

ref 방식은 참조 조건 (Equal 비교 조건)으로 어떤 값이 제공 됐는지 보여준다. 만약 상수 값으로 지정했다면 const, 다른 테이블의 컬럼 값이면 그 테이블 명과 컬럼 명이 표시된다.

만약 참조 조건에 대한 값을 함수나 연산을 통해 명시적으로 변경할 경우, `func` 가 표시된다. 또한 다른 컬럼의 타입으로 조인할 때에도 MySQL 내부적으로 변환하는 과정을 거치게 된다.

---

## rows

MySQL 옵티마이저가 실행계획을 수립할 때 해당 쿼리에서 얼마나 많은 레코드를 읽고 비교해야 하는지 통계를 내고 예측하여 많은 실행 계획중 하나를 선택하게 된다. 대상 테이블의 레코드 또는 인덱스 값의 분포도가 어떤지를 통계 정보를 기준으로 조사하는 것이다.

rows 컬럼은 옵티마이저가 실행 계획의 효율성을 고려하는 과정에서 예측했던 처리 할 레코드의 수다.

---

## Extra

### const row not found

const 접근 방식으로 테이블을 읽었지만 실제로 해당 테이블에 레코드가 하나도 존재하지 않으면 표시된다.

### Distinct

DISTINCT를 처리하기 위해 조인하지 않아도 되는 항목은 모두 무시하고 꼭 필요한 것만 조인했음을 알 수 있는 키워드

### Full scan on NULL key

“NULL IN (SELECT col2 FROM ...)” 와 같은 쿼리는 다음과 같은 조건 하에서 실행된다.

- 서브 쿼리가 1건이라도 결과 레코드를 가진다면 최종 비교 결과는 NULL
- 서브 쿼리가 1건의 결과도 가지지 않는다면 비교 결과는 FALSE

이는 서브 쿼리에서 풀 테이블 스캔을 해야만 결과를 알아낼 수 있다. Full scan on NULL key는 풀 테이블 스캔을 사용할 것이라는 사실을 알려주는 키워드다.

### Impossible HAVING

쿼리에 사용된 HAVING 절의 조건을 만족하는 레코드가 없을 때 표시된다. 애플리케이션 쿼리 중 실행 계획에 이 메시지가 출력된다면 해당 제대로 작성되지 못한 경우가 대부분이므로 다시 점검을 하는게 좋다.

### Impossible WHERE

WHERE 조건이 항상 FALSE가 될 수 밖에 없는 경우 표시된다.

### Impossible WHERE noticed after reading const tables

옵티마이저가 일부 쿼리를 실행 해보고 판단한 결과가 출력된 것. 실행 결과 불가능한 조건임을 판단한 결과로 표시된다.

### No matching min/max row

MIN(), MAX()와 같은 집합 함수가 있는 쿼리의 조건절(WHERE)에 일치하는 레코드가 한 건도 없을 때 Extra 컬럼에 No matching min/max row 메시지가 표시된다.

### no matching row in const table

```sql
SELECT *
FROM dept_emp de,
(SELECT emp_no FROM employees WHERE emp_no = 0) tb1
WHERE tb1.emp_no=de.emp_no AND de.dept_no='d005';
```

상단의 쿼리에서 `emp_no=0` 을 만족하는 레코드는 존재할 수 없는데, 이와 같이 실행 계획을 만들기 위한 기초 자료가 없음을 의미한다.

### No tables used

다른 DBMS와 달리 MySQL은 FROM 절이 없는 쿼리 실행이 가능한데, 이처럼 FROM 절이 없는 쿼리 문장이나 FROM DUAL 형태의 쿼리 실행 계획에서 표시된다.

### Not exists

A 테이블에는 존재하지만 B 테이블에 존재하지 않는 값을 조회하는 경우, NOT IN 형태나 NOT EXISTS를 사용할 수 있다. 또한 아우터 조인과 `IS NOT NULL` 을 통해서도 가능한데, 비교적 더 빠른 성능을 낼 수 있다.

이렇게 아우터 조인을 이용해 안티 조인을 수행하는 쿼리에서는 Extra 컬럼에 Not exists 메시지가 표시된다.

### Range checked for each record

```sql
SELECT *
FROM employees e1, employees e2
WHERE e2.emp_no >= e1.emp_no;
```

위와 같이 두 테이블을 조인하는 상황에서 조인 조건에 상수가 없고 둘 다 변수인 경우, 인덱스 레인지 스캔과 테이블 풀 스캔 중 어느 것이 효율적인지 판단할 수 없게 된다. 이 때 e1 테이블의 레코드를 읽을 때 마다 쿼리 비용 추정 기준이 달라지므로 옵티마이저가 실행 계획을 계속 계산하는데, 이 때 표시되는 문장이다.

### Scanned N databases

```sql
SELECT table_name
FROM information_schema.tables
WHERE table_schema = 'employees' AND table_name = 'employees';
```

INFORMATION_SCHEMA DB는 MySQL 서버 내에 존재하는 DB의 메타 정보 (테이블, 컬럼, 인덱스 등의 스키마 정보)를 모아둔 DB다. 이 DB의 테이블은 레코드가 있는 것이 아니라 단순히 쿼리를 실행할 때마다 MySQL 서버의 메모리에서 가져와 보여준다. 간단히 정리하면, INFORMATION_SCHEMA DB를 조회할 때 표시되는 문장이라 할 수 있다. N이 의미하는 것들은 다음과 같다.

- 0 : 특정 테이블의 정보만 요청되어 데이터베이스 전체의 메타 정보를 읽지 않음
- 1: 특정 데이터베이스내의 모든 스키마 정보가 요청되어 해당 데이터베이스의 모든 스키마 정보를 읽음
- All : MySQL 서버 내의 모든 스키마 정보를 다 읽음

### Select tables optimized away

MIN() MAX()를 사용하는 쿼리가 인덱스를 오름차순 또는 내림차순으로 1건만 읽는 형태의 최적화가 적용되는 경우 표시된다.

### Skip_open_table, Open_frm_only, Open_trigger_only, Open_full_table

INFORMATION_SCHEMA DB의 메타 정보를 조회하는 SELECT 쿼리의 실행 계획에서만 표시되는 내용이다. 테이블 메타 정보가 저장된 파일 (.FRM), 트리거가 저장된 파일 (.TRG) 또는 데이터 테이블에서 필요한 파일만 읽었는지 등의 정보를 보여준다.

- Skip_open_table : 테이블의 메타 정보가 저장된 파일을 별도로 읽을 필요가 없음
- Open_frm_only : 테이블의 메타 정보가 저장된 파일만 열어서 읽음
- Open_trigger_only : 트리거 정보가 저장된 파일만 열어서 읽음
- Open_full_table : 최적화되지 못해서 테이블 메타 정보 파일과 데이터 및 인덱스 파일까지 모두 읽음

### unique row not found

두 테이블이 각각 유니크 컬럼으로 아우터 조인을 수행하는 쿼리에서 아우터 테이블에 일치하는 레코드가 존재하지 않을 때 이 코멘트가 표시된다.

### Using filesort

ORDER BY를 처리하기 위해 인덱스를 이용할 수도 있지만 적절한 인덱스를 사용하지 못할 때는 MySQL 서버가 조회된 레코드를 다시 한번 정렬한다. ORDER BY 처리가 인덱스를 사용하지 못할 때 표시되며, 조회된 레코드 정렬을 위해 메모리 버퍼(소트 버퍼)에 복사해 퀵 소트 알고리즘을 수행한다.

### Using index

데이터 파일을 전혀 읽지 않고 인덱스만 읽어서 쿼리를 모두 처리할 수 있을때 표시된다. 이렇게 인덱스만으로 처리되는 것을 커버링 인덱스라 한다.

> InnoDB의 모든 테이블은 클러스터링 인덱스로 구성되어 있다. 이 때문에 InnoDB 테이블의 모든 보조 인덱스는 데이터 레코드의 주소 값으로 프라이머리 키 값을 가진다.

### Using index for group-by

GROUP BY 처리를 위해 MySQL 서버는 그룹핑 기준 컬럼을 이용해 정렬 작업을 수행하고 다시 정렬된 결과를 그룹핑하는 형태의 고부하 작업을 필요로 한다. 하지만 인덱스를 이용하면 정렬된 인덱스 컬럼을 순서대로 읽기만 하면 그룹핑 작업만 수행한다. 이렇게 GROUP BY 처리에 인덱스를 이용하면 레코드의 정렬이 불필요해지고, 인덱스의 필요한 부분만 읽으면 되기 때문에 성능이 많이 빨라진다.

GROUP BY 처리를 위해 인덱스를 읽는 방법을 루스 인덱스 스캔이라 한다. 인덱스를 쭉 읽는 타이트 인덱스 스캔과는 달리 루스 인덱스 스캔은 인덱스에서 필요한 부분만 듬성듬성 읽는다.

### Using join buffer

일반적으로 빠른 쿼리 실행을 위해 조인이 되는 컬럼은 인덱스를 생성한다. 조인에 필요한 인덱스는 조인되는 양쪽 테이블 컬럼 모두가 필요한 것이 아닌 조인에서 뒤에 읽는 테이블의 컬럼에만 필요하다.

> RDBMS에서 조인을 처리하는 방법은 2~3가지 정도 되지만 MySQL에서는 중첩 루프 조인 방식만 지원한다. FROM절에 아무리 많은 테이블이 있어도 조인을 수행할 때는 반드시 두 개의 테이블이 비교되는 방식으로 처리가 되는 것이다. 조인이 수행될 때 먼저 읽는 테이블을 드라이빙 테이블이라 하고, 뒤에 읽는 테이블을 드리븐 테이블이라 한다.

조인이 수행될 때 드리븐 테이블에 검색을 위한 적절한 인덱스가 없다면 드라이빙 테이블로부터 읽은 레코드의 건수만큼 매번 드라이븐 테이블을 풀 테이블 스캔이나 인덱스 풀 스캔해야 할 것이다.
조인이 수행될 때 비효율적인 검색을 보완하기 위해 MySQL 서버는 드라이빙 테이블에서 읽은 레코드를 임시 공간에 보관해두는데, 읽은 레코드를 임시로 보관해두는 메모리 공간을 조인 버퍼라 하고, 조인 버퍼가 사용된 실행 계획의 Extra 컬럼에 Using join buffer라는 메시지가 표시된다.

### Using sort_union, Using union, Using intersect

쿼리가 Index_merge 접근 방식으로 실행되는 경우는 2개 이상의 인덱스가 동시에 사용될 수 있다. 이 때 두 인덱스로부터 읽은 결과를 어떻게 병합했는지를 조금 더 상세하게 설명하기 위해 Extra 컬럼에 다음 중 하나의 메시지를 출력한다.

1. Using intersect - 각각의 인덱스를 사용할 수 있는 조건이 AND로 연결된 경우 각 처리 결과에서 교집합을 추출해내는 작업을 수행하였다.
2. Using union - 각 인덱스를 사용할 수 있는 조건이 OR로 연결된 경우 각 처리 결과에서 합집합을 추출하는 작업을 수행하였다.
3. Using sort_union - Using union과 같은 작업을 수행하지만 Using union으로 처리될 수 없는 경우 이 방식으로 처리된다. (OR로 연결된 대량의 range 조건들) Using_union과의 차이점은 프라이머리 키만 먼저 읽어서 정렬하고 병합한 후에야 비로소 레코드를 읽어서 반환할 수 있다는 것이다.

### Using temporary

MySQL은 쿼리를 처리하는 동안 중간 결과를 담아 두기 위해 임시 테이블을 사용한다. 임시 테이블은 메모리나 디스크에 생성될 수 있다. Using temporary가 표시되면 임시 테이블을 사용한 것이고, 이 때 이 테이블이 메모리에 생성된 것인지 디스크에 생성된 것인지는 실행 계획만으로 판단할 수 없다.

임시테이블이 필요한 대표적인 케이스는 다음과 같다.

- FROM 절에 서브쿼리 사용 (Derived table)
- COUNT(DISTINCT column1)을 포함하는 쿼리가 인덱스를 사용할 수 없는 경우
- UNION이나 UNION ALL이 사용된 쿼리
- 인덱스를 사용하지 못하는 정렬 작업

### Using where

MySQL은 내부적으로 MySQL엔진, 스토리지 엔진이라는 두 레이어로 나눌 수 있다. 각 스토리지 엔진은 디스크, 메모리에서 필요한 레코드를 읽거나 저장하는 역할을 하고, MySQL 엔진은 스토리지 엔진으로부터 받은 레코드를 가공 또는 연산하는 작업을 수행한다. MySQL엔진 처리의 간단하고도 대표적인 케이스가 작업 범위 제한 조건이 아닌 체크 조건을 처리하는 경우이다. 작업 범위 제한 조건은 스토리지 엔진에서 처리되는 반면, 체크 조건은 MySQL 엔진 레이어에서 처리한다.
MySQL 엔진에서 별도의 가공을 통해 작업을 처리한 경우에 Using where 문구가 표시된다.

### EXPLAIN EXTENDED (Filtered 컬럼)

Using where에서 MySQL 엔진에 의해 걸러지는 레코드 수를 추측할 수 있는데, 필터링 되어 제거된 레코드는 제외하고 최종적으로 레코드가 얼마나 남았는지의 비율이 표시된다.

### EXPLAIN EXTENDED(추가 옵티마이저 정보)

분석된 파스 트리를 재조합해서 쿼리 문장과 비슷한 순서대로 나열해서 보여준다. 이를 통해 옵티마이저가 어떻게 쿼리를 해석하고, 어떻게 변환했는지, 또한 특수한 처리가 수행됐는지 등을 판단할 수 있다.

### EXPLAIN PARTITIONS (Partitions 컬럼)

쿼리를 실행하기 위해 테이블의 파티션 중 어떤 파티션을 사용했는지 등의 정보를 조회할 수 있다.

> 파티션이 여러개인 테이블에서 불필요한 파티션을 빼고 쿼리를 수행하기 위해 접근해야 할 것으로 판단되는 테이블만 골라내는 과정을 `파티션 프루닝`이라 한다.
