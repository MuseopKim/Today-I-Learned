------



## InnoDB 스토리지 엔진의 특성

### 프라이머리 키에 의한 클러스터링

InnoDB의 모든 테이블은 프라이머리 키를 기준으로 클러스터링 되어 저장 된다. 결과적으로 쿼리의 실행 계획에서 다른 보조 인덱스보다 프라이머리 키가 선택 될 확률이 높다.



### 잠금이 필요 없는 일관된 읽기

InnoDB 스토리지 엔진은 MVCC라는 기술을 이용해 락을 걸지 않고 읽기 작업을 수행한다.



### 외래 키 지원

외래 키에 대한 지원은 InnoDB 스토리지 엔진 레벨에서 지원하는 기능으로 MyISAM이나 MEMORY 테이블에서는 사용할 수 없다.



### 자동 데드락 감지

InnoDB는 그래프 기반의 데드락 체크 방식을 사용하기 때문에 데드락이 발생함과 동시에 바로 감지되고, 감지된 데드락은 관련 트랜잭션 중에 롤백이 가장 용이한 트랜잭션을 자동적으로 강제 종료 해버린다.



### 자동화된 장애 복구

InnoDB에는 손실이나 장애로부터 데이터를 보호하기 위한 여러 가지 메커니즘이 탑재 되어 있다. 완료 되지 못한 트랜잭션이나 디스크에 일부만 기록된 데이터 페이지등에 대한 일련의 복구 작업이 자동으로 진행된다.



---



## InnoDB 버퍼 풀

디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시 해두는 공간을 말한다. 쓰기 작업을 지연 시켜 일괄 작업으로 처리할 수 있게 해주는 버퍼 역할도 같이 한다. 일반적으로 전체 장착된 물리 메모리의 50 ~ 80% 수준에서 버퍼 풀의 메모리 크기를 결정한다.



---



## Undo 로그

Undo는 다음과 같은 두 가지 용도로 사용 된다.

1. 트랜잭션 롤백 대비용

2. 트랜잭션의 격리 수준을 유지하면서 높은 동시성을 제공

   Undo 영역은 UPDATE, DELETE와 같은 문장으로 데이터를 변경했을 때 변경되기 전의 데이터를 보관하는 곳이다.

```bash
mysql> UPDATE member SET name ='홍길동' WHERE member_id='1';
```

위와 같은 문장이 실행되면 트랜잭션을 커밋하지 않아도 실제 데이터 파일 내용은 '홍길동' 으로 변경 된다. 이 때 Undo 영역에는 변경 전 값이 백업 되어 있다. 만약 사용자가 커밋을 하면 변경된 값이 그대로 유지 되고, 롤백을 하면 Undo 영역의 백업된 데이터를 다시 데이터 파일로 복구 한다.



**트랜잭션 격리 수준**

동시에 여러 트랜잭션이 데이터를 변경하거나 조회할 때 한 트랜잭션의 작업 내용이 다른 트랜잭션에 어떻게 보여질지를 결정하는 기준



---



## Insert 버퍼

레코드가 INSERT 되거나 UPDATE 될 때 데이터 파일을 변경하는 작업 뿐 아니라 해당 테이블에 포함된 인덱스를 업데이트 하는 작업이 필요하다. 하지만 이는 적지 않은 자원을 소모하는 일이다. 그래서 InnoDB는 변경해야 할 인덱스 페이지가 버퍼 풀에 있으면 바로 업데이트를 수행하지만, 그렇지 않다면 이를 즉시 실행하지 않고 임시 공간에 저장해둔 뒤 바로 사용 사용자에게 결과를 반환하는 형태로 성능을 향상 시키는데, 이때 사용하는 메모리 공간을 인서트 버퍼라 한다.



---



## Redo 로그 및 로그 버퍼

- Redo 로그 : 변경된 데이터를 순차적으로 디스크에 기록하는 로그 파일
- 로그 버퍼 : 사용량이 매우 많은 DBMS 서버의 경우 Redo 로그 기록이 큰 문제가 되기도 하는데, 이를 보완하기 위해 최대한 ACID를 속성을 보장하는 수준에서 버퍼링을 하게 된다. 이러한 Redo 로그 버퍼링에 사용되는 공간을 로그 버퍼라 한다.



**ACID**

트랜잭션의 무결성을 보장하기 위해 반드시 필요한 4가지 요소

- Atomic : 트랜잭션은 원자성 작업이어야 한다.
- Considstent : 일관성을 유지해야 한다.
- Isolated : 격리성을 가져야 한다.
- Durable : 한번 저장된 데이터는 지속적으로 유지되어야 한다.



---



## MVCC(Multi Version Concurrency Control)

잠금을 사용하지 않는 일관된 읽기를 제공하는 기능을 말한다. 어떠한 데이터에 UPDATE 쿼리가 실행 되고, 해당 데이터를 조회 할 경우 격리 수준에 따라 다른 데이터를 반환하게 된다. 예를 들어 READ_UNCOMMITTED인 경우에는 InnoDB 버퍼 풀이나 데이터 파일로부터 변경되지 않은 데이터를 읽어서 반환하게 되고, READ_COMMITTED나 그 이상의 격리 수준인 경우 아직 커밋 되지 않았기 때문에 InnoDB 버퍼 풀이나 데이터 파일에 있는 내용 대신 변경되기 이전의 내용을 보관하고 있는 Undo 영역의 데이터를 반환한다. 이러한 과정을 DBMS에서 MVCC라 표현한다. 즉 하나의 레코드에 대해 2개의 버전이 유지되고, 필요에 따라 어떤 데이터가 보여지는지 여러  가지 상황에 따라 달라지는 구조다.



---



## 잠금 없는 일관된 읽기(Non-locking consistent read)

InnoDB에서 격리 수준이 SERIALIZABLE이 아닌 READ-UNCOMMITTED, READ_COMMITTED, REPEATABLE-READ 수준인 경우 INSERT와 연결되지 않은 순수한 읽기 작업은 다른 트랜잭션의 변경 작업과 관계없이 항상 잠금을 대기하지 않고 바로 실행된다. 특정 사용자가 레코드를 변경하고 아직 커밋을 수행하지 않았다 하더라도 변경 트랜잭션이 다른 사용자의 SELECT 작업을 방해하지 않는데, 이를 '잠금 없는 일관된 읽기'라 한다. 이때 InnoDB에서는 변경되기 전의 데이터를 읽기 위해 Undo 로그를 사용한다.



---



## InnoDB와 MyISAM 스토리지 엔진 비교

MySQL 5.5부터 InnoDB 스토리지 엔진이 기본 스토리지 엔진으로 채택 됐다. MyISAM 스토리지 엔진이 인덱스를 위한 키 캐시를 가지고 있지만 데이터 자체는 운영체제의 캐시에 의존하는 반면 InnoDB 스토리지 엔진은 자체적인 버퍼 풀을 가지고 좀 더 업무 특성에 맞는 캐싱이나 버퍼링이 가능하다.



---



## InnoDB와 MEMORY(HEAP) 스토리지 엔진 비교

MEMORY 스토리지 엔진의 가장 큰 장점은 데이터와 인덱스를 모두 메모리에 저장하기 때문에 저장 작업이나 읽기 작업이 매우 빠르다. 그러나 레코드 수준의 잠금이 아니라 테이블 수준의 잠금을 이용하므로 두 개 이상의 클라이언트가 테이블의 변경을 수행할 수 없다. 이러한 테이블 수준의 잠금을 사용하는 경우 동시에 많은 커넥션이 트랜잭션을 유발하는 OLTP 환경에서는 적합하지 않다.