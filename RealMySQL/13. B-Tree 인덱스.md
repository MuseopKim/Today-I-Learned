# B-Tree 인덱스

---

데이터베이스의 인덱싱 알고리즘 가운데 가장 일반적으로 사용되고 가장 먼저 도입 된 알고리즘이며, 동시에 가장 범용적인 목적으로 사용되는 인덱스 알고리즘이다.

---

## 구조 및 특성

B-Tree는 트리 구조의 최상위에 하나의 루트 노드가 존재하고 그 하위에 자식 노드가 붙어 있는 형태다. 가장 하위에 있는 노드를 `리프 노드`라하고, 루트 노드도 아니고 리프 노드도 아닌 중간 노드를 `브랜치 노드`라 한다
인덱스와 실제 데이터가 저장된 데이터는 따로 관리가 되는데, 인덱스의 리프 노드는 항상 실제 데이터 레코드의 주소 값을 가지고 있다.

인덱스는 정렬 된 순서를 유지하며 데이터는 정렬되지 않는다. 흔히 데이터가 저장되는 순서를 보장할 것이라 생각 하는데 INSERT만 수행되는 것이 아닌 삭제가 실행 된다면 그 다음의 INSERT는 빈 공간을 재활용 하도록 설계된다.

클러스터란 비슷한 값들을 최대한 모아서 저장하는 방식을 의미한다. 대부분의 RDBMS의 데이터 파일에서 레코드는 특정 기준으로 정렬 되는 것이 아닌 임의의 순서로 저장 된다. 그러나 InnoDB의 경우 레코드는 클러스터되어 디스크에 저장 되므로 기본적으로 프라이머리 키 순서대로 정렬되어 저장된다.

인덱스는 테이블의 키 컬럼만 가지고 있으므로 나머지 컬럼을 읽으려면 데이터 파일에서 해당 레코드를 찾아야 한다. 이를 위해 인덱스의 리프 노드는 데이터 파일에 저장된 레코드의 주소를 가진다.

### 레코드 주소

레코드 주소는 DBMS의 종류나 MySQL의 스토리지 엔진에 따라 의미가 달라진다. 오라클은 물리적 주소, MyISAM 테이블에서는 내부적인 레코드의 아이디를 의미한다. InnoDB는 프라이머리 키에 의해 클러스터링 되기 때문에 프라이머리 키 값 자체가 주소 역할을 한다. MySQL 테이블의 인덱스는 항상 인덱스 컬럼 값과 주소 값의 조합이 인덱스 레코드로 구성된다.

---

## B-Tree 인덱스 키 추가 및 삭제

### 인덱스 키 추가

새로운 키 값이 B-Tree에 저장될 때 테이블의 스토리지 엔진에 따라 새로운 키 값이 즉시 인덱스에 저장될 수도 있고 아닐 수도 있다. B-Tree에 저장될 때는 저장 될 키 값을 이용해서 적절한 위치를 검색하는데, 위치가 결정 되면 레코드의 키 값 및 대상 레코드의 주소를 리프노드에 저장한다. 만약 리프 노드가 꽉 차서 저장할 수 없게 되면 리프 노드를 분리해야 하는데, 이는 상위 브랜치 노드까지 영향을 미친다.
이러한 탓에 쓰기 작업에 비용이 많이 들게 된다.

### 인덱스 키 삭제

삭제 대상 레코드 키 값이 저장된 B-Tree의 리프 노드를 찾아서 삭제 마크를 작업한다. 삭제 마킹된 인덱스 공간은 방치되거나 재활용할 수 있다.

### 인덱스 키 변경

인덱스의 키 값은 그 값에 따라 저장될 리프 노드의 위치가 결정된다. 따라서 B-Tree 키 값이 변경된 후 단순히 인덱스 상의 키 값만 변경하는 것은 불가능하다.

### 인덱스 키 검색

결국 인덱스를 사용하는 이유는 빠른 검색을 위해서다. B-Tree의 루트 노드, 브랜치 노드, 리프 노드까지 순회하면서 비교 작업을 수행하는데, 이 과정을 트리 탐색이라 한다.

B-Tree인덱스를 이용한 검색은 100% 일치 또는 값의 앞부분만 일치하는 경우 사용할 수 있다. `<>`, 값의 뒷 부분이 일치하는 경우에 대해서는 B-Tree 인덱스를 이용한 검색이 불가능하다. 또한 인덱스의 키 값에 변형이 가해진 이후에는 절대 B-Tree의 빠른 검색을 사용할 수 없다.

### 인덱스 키 값의 크기

InnoDB 스토리지 엔진은 디스크에 데이터를 저장하는 가장 기본 단위를 페이지 혹은 블록이라 한다. 디스크의 모든 읽기, 쓰기 작업의 최소 작업 단위인 것이다. 또한 페이지는 InnoDB 스토리지 엔진의 버퍼 풀에서 데이터를 버퍼링 하는 기본 단위이다.

### 선택도(기수성 - Cardinality)

인덱스의 값이 유니크 할수록 쿼리의 효율성이 높아진다. 예를 들어 총 10000개의 데이터가 있는 테이블에서 컬럼의 유니크 값이 10개 이면 하나의 레코드를 검색하기 위해 1000개의 데이터를 읽게 되고, 999개는 불필요하게 읽는 데이터가 된다. 반면 유니크한 값이 1000개이면 평균 10개씩 데이터가 존재하게 되고, 이 때는 1개의 데이터를 검색을 위해 9건의 레코드만 불필요하게 읽은 것이 된다.

### 인덱스의 효율성

인덱스를 이용한 읽기의 손익 분기점을 잘 따져볼 필요가 있는데, 일반적인 DBMS 옵티마이저는 인덱스를 통해 레코드 1건 읽는 것을 그냥 레코드를 읽는 작업보다 4~5배 많은 비용이 드는 작업으로 여긴다. 인덱스를 통해 읽어야 할 레코드 건수가 전체 테이블 레코드의 20~25%를 넘어서면 인덱스를 이용하지 않고 직접 테이블을 모두 읽어서 필요한 레코드만 가려내는 방식으로 처리하는 것이 효율적이다.

---
