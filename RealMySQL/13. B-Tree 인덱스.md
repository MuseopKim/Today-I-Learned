# B-Tree 인덱스

---

데이터베이스의 인덱싱 알고리즘 가운데 가장 일반적으로 사용되고 가장 먼저 도입 된 알고리즘이며, 동시에 가장 범용적인 목적으로 사용되는 인덱스 알고리즘이다.

---

## 구조 및 특성

B-Tree는 트리 구조의 최상위에 하나의 루트 노드가 존재하고 그 하위에 자식 노드가 붙어 있는 형태다. 가장 하위에 있는 노드를 `리프 노드`라하고, 루트 노드도 아니고 리프 노드도 아닌 중간 노드를 `브랜치 노드`라 한다
인덱스와 실제 데이터가 저장된 데이터는 따로 관리가 되는데, 인덱스의 리프 노드는 항상 실제 데이터 레코드의 주소 값을 가지고 있다.

인덱스는 정렬 된 순서를 유지하며 데이터는 정렬되지 않는다. 흔히 데이터가 저장되는 순서를 보장할 것이라 생각 하는데 INSERT만 수행되는 것이 아닌 삭제가 실행 된다면 그 다음의 INSERT는 빈 공간을 재활용 하도록 설계된다.

클러스터란 비슷한 값들을 최대한 모아서 저장하는 방식을 의미한다. 대부분의 RDBMS의 데이터 파일에서 레코드는 특정 기준으로 정렬 되는 것이 아닌 임의의 순서로 저장 된다. 그러나 InnoDB의 경우 레코드는 클러스터되어 디스크에 저장 되므로 기본적으로 프라이머리 키 순서대로 정렬되어 저장된다.

인덱스는 테이블의 키 컬럼만 가지고 있으므로 나머지 컬럼을 읽으려면 데이터 파일에서 해당 레코드를 찾아야 한다. 이를 위해 인덱스의 리프 노드는 데이터 파일에 저장된 레코드의 주소를 가진다.

### 레코드 주소

레코드 주소는 DBMS의 종류나 MySQL의 스토리지 엔진에 따라 의미가 달라진다. 오라클은 물리적 주소, MyISAM 테이블에서는 내부적인 레코드의 아이디를 의미한다. InnoDB는 프라이머리 키에 의해 클러스터링 되기 때문에 프라이머리 키 값 자체가 주소 역할을 한다. MySQL 테이블의 인덱스는 항상 인덱스 컬럼 값과 주소 값의 조합이 인덱스 레코드로 구성된다.

---

## B-Tree 인덱스 키 추가 및 삭제

### 인덱스 키 추가

새로운 키 값이 B-Tree에 저장될 때 테이블의 스토리지 엔진에 따라 새로운 키 값이 즉시 인덱스에 저장될 수도 있고 아닐 수도 있다. B-Tree에 저장될 때는 저장 될 키 값을 이용해서 적절한 위치를 검색하는데, 위치가 결정 되면 레코드의 키 값 및 대상 레코드의 주소를 리프노드에 저장한다. 만약 리프 노드가 꽉 차서 저장할 수 없게 되면 리프 노드를 분리해야 하는데, 이는 상위 브랜치 노드까지 영향을 미친다.
이러한 탓에 쓰기 작업에 비용이 많이 들게 된다.

### 인덱스 키 삭제

삭제 대상 레코드 키 값이 저장된 B-Tree의 리프 노드를 찾아서 삭제 마크를 작업한다. 삭제 마킹된 인덱스 공간은 방치되거나 재활용할 수 있다.

### 인덱스 키 변경

인덱스의 키 값은 그 값에 따라 저장될 리프 노드의 위치가 결정된다. 따라서 B-Tree 키 값이 변경된 후 단순히 인덱스 상의 키 값만 변경하는 것은 불가능하다.

### 인덱스 키 검색

결국 인덱스를 사용하는 이유는 빠른 검색을 위해서다. B-Tree의 루트 노드, 브랜치 노드, 리프 노드까지 순회하면서 비교 작업을 수행하는데, 이 과정을 트리 탐색이라 한다.

B-Tree인덱스를 이용한 검색은 100% 일치 또는 값의 앞부분만 일치하는 경우 사용할 수 있다. `<>`, 값의 뒷 부분이 일치하는 경우에 대해서는 B-Tree 인덱스를 이용한 검색이 불가능하다. 또한 인덱스의 키 값에 변형이 가해진 이후에는 절대 B-Tree의 빠른 검색을 사용할 수 없다.

### 인덱스 키 값의 크기

InnoDB 스토리지 엔진은 디스크에 데이터를 저장하는 가장 기본 단위를 페이지 혹은 블록이라 한다. 디스크의 모든 읽기, 쓰기 작업의 최소 작업 단위인 것이다. 또한 페이지는 InnoDB 스토리지 엔진의 버퍼 풀에서 데이터를 버퍼링 하는 기본 단위이다.

### 선택도(기수성 - Cardinality)

인덱스의 값이 유니크 할수록 쿼리의 효율성이 높아진다. 예를 들어 총 10000개의 데이터가 있는 테이블에서 컬럼의 유니크 값이 10개 이면 하나의 레코드를 검색하기 위해 1000개의 데이터를 읽게 되고, 999개는 불필요하게 읽는 데이터가 된다. 반면 유니크한 값이 1000개이면 평균 10개씩 데이터가 존재하게 되고, 이 때는 1개의 데이터를 검색을 위해 9건의 레코드만 불필요하게 읽은 것이 된다.

### 인덱스의 효율성

인덱스를 이용한 읽기의 손익 분기점을 잘 따져볼 필요가 있는데, 일반적인 DBMS 옵티마이저는 인덱스를 통해 레코드 1건 읽는 것을 그냥 레코드를 읽는 작업보다 4~5배 많은 비용이 드는 작업으로 여긴다. 인덱스를 통해 읽어야 할 레코드 건수가 전체 테이블 레코드의 20~25%를 넘어서면 인덱스를 이용하지 않고 직접 테이블을 모두 읽어서 필요한 레코드만 가려내는 방식으로 처리하는 것이 효율적이다.

---

## B-Tree 인덱스를 통한 데이터 읽기

### 인덱스 레인지 스캔

```sql
SELECT * FROM employees FROM first_name BETWEEN 'Ebbe' AND 'Gad';
```

인덱스 레인지 스캔은 검색해야 할 인덱스의 범위가 결정됐을 때 사용하는 방식이다. 검색하려는 값의 수나 검색 결과 레코드 건수와 관계없이 레인지 스캔이라 표현한다.

루트 노드에서 시작해 브랜치 노드를 거치고 최종적으로 리프 노드까지 찾아들어가면 비로소 실제 시작 지점을 찾을 수 있는데, 여기서부터 나머지 리프 노드의 레코드만 순서대로 읽으면 된다. 이처럼 차례대로 쭉 읽는 것을 스캔이라 한다. 만약 리프 노드의 끝까지 읽으면 리프 노드 간의 링크를 이용해서 다음 리프 노드를 찾아 다시 스캔한다. 최종적으로 스캔을 멈춰야 할 위치에 다다르면 지금까지 읽은 레코드를 사용자에게 반환한 뒤 쿼리를 끝낸다.

인덱스의 리프 노드에서 조건에 일치하는 건들은 데이터 파일에서 레코드를 읽어오는 과정이 따로 필요한데, 이 때 리프 노드에 저장된 레코드 주소로 한 건 한 건 단위로 랜덤 I/O가 발생한다.

### 인덱스 풀 스캔

인덱스 레인지 스캔과 마찬가지로 인덱스를 사용하지만 인덱스 레인지 스캔과는 달리 인덱스의 처음부터 끝까지 모두 읽는 방식을 인덱스 풀 스캔이라 한다. 대표적인 예로 인덱스의 첫 번째 컬럼이 아닌 컬럼을 조건으로 검색을 할 경우 인덱스 풀 스캔 방식을 사용한다. 쿼리가 인덱스에 명시된 컬럼만으로 조건을 처리할 수 있는 경우 주로 이 방식이 사용된다. 만약 레코드까지 모두 읽어야 한다면 절대 이 방식으로 처리되지 않을 것이다.

### 루스 인덱스 스캔

말 그대로 느슨하게 또는 듬성듬성하게 인덱스를 읽는 것을 의미한다. 앞 서 살펴 본 인덱스 레인지 스캔, 인덱스 풀 스캔은 타이트 인덱스 스캔이라 한다.

루스 인덱스 스캔은 인덱스 레인지 스캔과 비슷하게 작동하지만, 중간마다 필요하지 않은 인덱스 키 값은 SKIP 하고 다음으로 넘어가는 형태로 처리한다. GROUP BY, MAX(), MIN() 함수에 대한 최적화를 하는 경우에 주로 사용된다.

---

## 다중 컬럼 인덱스

실제 서비스용 데이터베이스에서는 2개 이상의 컬럼을 포함하는 인덱스가 더 많이 사용된다. 두 개 이상의 컬럼으로 구성된 인덱스를 다중 컬럼 인덱스라 한다.

다중 컬럼 인덱스의 특징은 앞 컬럼의 정렬에 뒷 컬럼의 정렬이 의존한다는 것이다. 첫 번째 인덱스 컬럼의 정렬이 먼저 수행되고, 이를 기준으로 두 번째 인덱스 컬럼, 세번 째 인덱스 컬럼을 정렬한다.

---

## B-Tree 인덱스의 정렬 및 스캔 방향

인덱스 키 값은 항상 오름차순으로만 정렬 된다. 이 때 그 인덱스를 끝에서부터 거꾸로 읽으면 반대로 내림차순으로 정렬된 인덱스 처럼 사용할 수 있다. 어느 방향으로 읽을지는 옵티마이저가 결정하게 된다.

### 인덱스의 정렬

일반 상용 DBMS에서는 인덱스를 생성하는 시점에 인덱스를 구성하는 각 컬럼의 정렬을 오름차순 또는 내림차순으로 정렬할 수 있다. 그러나 MySQL에서는 컬럼 단위로 혼합해서 생성하는 기능을 아직 지원하지 않는다.

### 인덱스 스캔 방향

인덱스를 역순으로 정렬되게 할 수는 없지만 인덱스를 읽는 방향에 따라 오름차순 또는 내림차순으로 정렬되어 있는 효과를 얻을 수 있다. 이는 전적으로 옵티마이저가 결정하게 된다.

---

## B-Tree 인덱스의 가용성과 효율성

최적화 된 쿼리와 인덱스를 구성하기 위해서는 쿼리의 WHERE, GROUP BY 또는 ORDER BY 절이 어떤 경우 인덱스를 사용할 수 있고 어떤 방식으로 사용하는지 식별할 수 있어야 한다.

### 비교 조건의 종류와 효율성

다중 컬럼 인덱스에서 각 컬럼의 순서, 조건이 동등 비교인지, 크다 또는 작다와 같은 범위 조건인지에 따라 인덱스 컬럼의 활용도가 달라진다. 이는 다중 컬럼 인덱스의 특징에서 비롯되는 것인데, 첫 번째 컬럼의 정렬에 두 번째 컬럼이 의존하고, 두 번째 컬럼의 정렬에 세 번째 컬럼의 정렬이 의존해서 발생하는 것이다.

### 인덱스의 가용성

B-Tree 인덱스의 특징은 왼쪽 값에 기준해서 오른쪽 값이 정렬 돼 있다는 것이다. 여기서의 왼쪽은 하나의 컬럼 내 값의 왼쪽, 다중 컬럼 인덱스의 왼쪽 컬럼 모두에 해당되는 말이다. 왼쪽 값을 모르면 인덱스 레인지 스캔 방식의 검색이 불가능해진다.

### 가용성과 효율성 판단

B-Tree 인덱스의 특성 상 다음 조건에서는 인덱스를 작업 범위 결정 조건으로 사용할 수 없다. 경우에 따라 체크 조건으로는 사용할 수 있지만 성능이 떨어진다.

- NOT-EQUAL로 비교된 경우 (<>, NOT IN, NOT BETWEEN, IS NOT NULL
- LIKE '%??' (앞 부분이 아닌 뒷 부분이 일치) 형태로 문자열 패턴이 비교된 경우
- 스토어드 함수나 다른 연산자로 인덱스 컬럼이 변형된 후 비교된 경우
- NOT-DETERMINISTIC 속성의 스토어드 함수가 비교 조건에 사용된 경우
- 데이터 타입이 서로 다른 비교(인덱스 컬럼의 타입을 변환해야 비교가 가능한 경우)
- 문자열 데이터 타입의 콜레이션이 다른 경우

### 작업 범위 결정 조건

```sql
INDEX ix_test (column_1, column_2, column_3, .., column_n)

-- 다음 쿼리는 인덱스를 사용할 수 없음
...WHERE column_1 <> 2

-- 다음 쿼리는 column_1과 column_2까지 범위 결정 조건으로 사용됨
...WHERE column_1 = 1 AND column_2 > 10

-- 다음 쿼리는 column_1, column_2, column_3 까지 범위 결정 조건으로 사용됨
...WHERE column_1 IN (1, 2) AND column_2 = 2 AND column_3 <= 10

-- 다음 쿼리는 column_1, column_2, column_3까지 범위 결정 조건으로,
-- column_4는 체크 조건으로 사용 됨
...WHERE column_1 = 1 AND column_2 = 2 AND column_3 IN (10, 20, 30) AND column_4 <> 100

-- 다음 쿼리는 column_1, column_2, column_3, column_4까지 범위 결정 조건으로 사용됨
-- 좌측 패턴 일치 LIKE 비교는 크다 또는 작다 비교와 동급으로 생각
...WHERE column_1 = 1 AND column_2 IN (2, 4) AND column_3 = 30 AND column_4 LIKE 'K%'

-- 다음 쿼리는 column_1, column_2, column_3, column_4, column_5 컬럼까지 모두 범위 결정 조건으로 사용됨
...WHERE column_1 = 1 AND column_2 = 2 AND column_3 = 30 AND column_4 = 'Kim' AND column_5 = 'Seoul'
```
