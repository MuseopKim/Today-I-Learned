# 트랜잭션

트랜잭션은 작업의 완전성을 보장해 준다. 즉, 한 단위의 작업을 모두 완벽하게 처리하지 못 할 경우 원 상태로 복구해서 작업의 일부만 적용 되는 현상이 발생되지 않게 만들어주는 기능이다.

잠금과 트랜잭션은 얼핏 서로 비슷한 개념 같아 보이기도 하는데, 잠금은 동시성을 제어하기 위한 기능이고 트랜잭션은 데이터의 정합성을 보장하기 위한 기능이다.

잠금은 여러 커넥션에서 동시에 동일한 자원을 요청할 경우 순서대로 한 시점에는 하나의 커넥션만 변경할 수 있게 해준다.

트랜잭션 격리수준이란, 여러 트랜잭션 간의 작업 내용을 어떻게 공유하고 차단할 것인지를 결정하는 레벨이다.

---

## MySQL에서의 트랜잭션

트랜잭션은 하나의 논리적인 작업 단위에 하나의 쿼리든, 그 이상이든 관계 없이 논리적인 한 단위 자체가 100% 적용 되거나(Commit) 적용되지 않아야 함을(Rollback) 보장해준다. MySQL의 InnoDB 스토리지 엔진은 이러한 트랜잭션을 보장하며, 부분 업데이트를 방지하여 데이터의 정합성을 맞출 수 있도록 돕는다.

```sql
try {
	START TRANSACTION;
	INSERT INTO table_a ...;
	INSERT INTO table_b ...;
	COMMIT;
} catch (exception) {
	ROLLBACK;
}
```

### 트랜잭션 주의사항

1. 데이터베이스 커넥션을 가지고 있는 범위와 트랜잭션이 활성화 돼 있는 프로그램의 범위를 최소화 해야 한다.
2. 외부 API 작업이 있는 경우 반드시 트랜잭션에서 배제해야 한다.

   ⇒ API에 장애가 발생 할 경우 DBMS 서버가 높은 부하 상태로 빠지거나 위험한 상태에 빠지는 경우가 빈번히 나타난다.

---

## MySQL 엔진의 잠금

MySQL 엔진 레벨의 잠금은 모든 스토리지 엔진에 영향을 미치지만, 스토리지 엔진 레벨의 잠금은 스토리지 엔진 간 상호 영향을 미치지 않는다.

### 글로벌 락

MySQL 서버 전체에 영향을 주는 MySQL에서 제공하는 락 중에 가장 범위가 큰 잠금을 말한다. "FLUSH TABLES WITH READ LOCK" 명령으로 획득할 수 있다. 만약 한 세션에서 글로벌 락을 획득하면 다른 세션에서 SELECT 이외에 다른 문장은 대기 상태로 남게 된다. mysqldump로 일관된 백업을 받아야 할 때 사용한다.

### 테이블 락

개별 테이블 단위로 설정되는 잠금을 말한다. 명시적 또는 묵시적으로 획득이 가능한데, "LOCK TABLES table_name[ READ | WRITE ]" 명령으로 특정 테이블의 락을 획득할 수 있다. 명시적으로 획득한 잠금은 UNLOCK TABLES 명령으로 잠금을 해제할 수 있다.

묵시적 테이블 락은 MyISAM, MEMORY테이블에 데이터를 변경하는 쿼리를 실행하면 발생한다. InnoDB 테이블의 경우 스토리지 엔진 차원에서 레코드 기반의 잠금을 제공하기 때문에 단순 데이터 변경 쿼리로 묵시적 테이블 락이 설정되지는 않는다. DML은 무시되지만 DDL의 경우에는 영향을 미친다.

### 유저 락

GET_LOCK() 함수를 이용해서 임의로 잠금을 설정한다. 이 잠금의 대상은 테이블이나 레코드가 아니다. 사용자가 지정한 문자열에 대한 잠금이다.

### 네임 락

데이터베이스의 이름을 변경하는 경우 획득하는 잠금. RENAME TABLE a TO b와 같이 테이블의 이름을 변경하는 경우 자동으로 획득하는 잠금이다.

---

## InnoDB 스토리지 엔진의 잠금

InnoDB 스토리지 엔진은 MySQL에서 제공하는 잠금과는 별개로 스토리지 엔진 내부에서 레코드 기반의 잠금 방식을 탑재하고 있다. 이 레코드 기반의 잠금 방식 덕분에 MyISAM보다 훨씬 뛰어난 동시성 처리를 제공한다. `INNODB_TRX`, `INNODB_LOCKS`, `INNODB_LOCK_WAITS` 테이블을 조인해서 조회하면 대기중인 잠금, 해당 잠금을 가지고 있는 트랜잭션을 확인할 수 있고, 장시간 잠금을 가지고 있는 클라이언트를 종료시킬 수 있다.

### InnoDB의 잠금 방식

**비관적 잠금**

현재 트랜잭션에서 변경하고자 하는 레코드에 대해 잠금을 획득하고 변경 작업을 처리하는 방식. 다른 트랜잭션에서도 해당 레코드를 변경할 수 있다는 가정을 하기 때문에 먼저 잠금을 획득한다. 높은 동시성 처리에 비관적 잠금이 유리하다고 알려져 있어 InnoDB는 비관적 잠금 방식을 채택하고 있다.

**낙관적 잠금**

각 트랜잭션이 같은 레코드를 변경 할 가능성이 희박하다 가정하고 우선 변경 작업을 수행한 뒤 마지막에 잠금 충돌이 있었는지 확인한다. 문제가 있었다면 ROLLBACK 한다.

---

## InnoDB의 잠금 종류

InnoDB 스토리지 엔진은 레코드 기반의 잠금을 제공한다. 잠금 정보가 작은 공간으로 관리되기 때문에 레코드 락이 페이지 락, 테이블 락으로 레벨업 되는 경우는 없다. 일반 상용 DBMS와는 조금 다르게 레코드 락 뿐만 아니라 레코드와 레코드 사이의 간격을 잠그는 갭 락이라는 것이 존재한다.

### 레코드 락

레코드 자체만을 잠그는 락. 다른 상용 DBMS의 레코드 락과 동일한 역할을 한다. 한가지 차이점으로 InnoDB 스토리지 엔진은 레코드 자체가 아닌 인덱스의 레코드를 잠근다는 점이 있다. 인덱스가 없는 테이블도 내부적으로 클러스터 인덱스를 이용해 잠금을 설정한다.

### 갭 락

레코드 자체가 아닌 레코드와 바로 인접한 레코드 사이의 간격만을 잠그는 락. 넥스트 키 락의 일부로 사용된다.

### 넥스트 키 락

레코드 락과 갭 락을 합쳐 놓은 형태의 잠금. InnoDB의 갭 락이나 넥스트 키 락은 바이너리 로그에 기록되는 쿼리가 슬레이브에서 실행될 때 마스터에서 만들어 낸 결과와 동일한 결과를 만들어내도록 보장하는 것이 주 목적이다. 데드락이나 다른 트랜잭션을 기다리게 만드는 일이 빈번하기 때문에 가능하면 바이너리 로그 포맷을 ROW 형태로 바꿔서 넥스트 키 락이나 갭 락을 줄이는 것이 좋다.

### 자동 증가 락

AUTO_INCREMENT 컬럼이 사용된 테이블에 동시에 여러 레코드가 INSERT 되는 경우, 저장되는 각 레코드는 중복되지 않고 저장된 순서대로 증가한 일련번호 값을 가져야 한다. 이를 위해 InnoDB에서 내부적으로 AUTO_INCREMENT 락이라는 테이블 수준의 잠금을 사용한다. 하지만 아주 짧은 시간 동안만 걸렸다가 해제되는 락이라서 대부분의 경우 문제가 되지 않는다.

자동 증가 값은 한번 증가하면 절대 줄어들지 않는 이유가 AUTO_INCREMENT 잠금을 최소화하기 위해서다. INSERT 쿼리가 실패 하더라도 AUTO_INCREMENT 값은 다시 줄어들지 않고 그대로 남게 된다.

---

## 인덱스와 잠금

InnoDB의 잠금과 인덱스는 중요한 연관관계가 있다. InnoDB의 잠금은 레코드 자체를 잠그는 것이 아니라 인덱스를 잠그는 방식으로 동작하기 때문이다. 즉, 변경해야 할 레코드를 찾기 위해 검색한 인덱스의 레코드를 모두 잠가야 한다.

```sql
// first_name에 인덱스가 걸려 있는 상황을 가정
// first_name = 'Georgi' 가 253건임을 가정
mysql> UPDATE employees SET hire_date=NOW()
			 WHERE first_name = 'Georgi' AND last_name = 'Klassen';
// => UPDATE를 수행하는데에 253건에 대한 락이 걸린다.
```

---

## 트랜잭션 격리 수준과 잠금

레코드 기반의 바이너리 로그를 사용하거나 바이너리 로그를 사용하지 않는 경우 InnoDB의 갭 락이나 넥스트 키 락의 사용을 대폭 줄일 수 있다. 이렇게 하면 위 예제의 경우 처음 인덱스 검색 시 253건의 데이터에 대해 잠금을 걸지만, 나머지 조건을 비교해서 일치하지 않는 레코드는 잠금을 해제한다.

---
