# 트랜잭션

트랜잭션은 작업의 완전성을 보장해 준다. 즉, 한 단위의 작업을 모두 완벽하게 처리하지 못 할 경우 원 상태로 복구해서 작업의 일부만 적용 되는 현상이 발생되지 않게 만들어주는 기능이다.

잠금과 트랜잭션은 얼핏 서로 비슷한 개념 같아 보이기도 하는데, 잠금은 동시성을 제어하기 위한 기능이고 트랜잭션은 데이터의 정합성을 보장하기 위한 기능이다.

잠금은 여러 커넥션에서 동시에 동일한 자원을 요청할 경우 순서대로 한 시점에는 하나의 커넥션만 변경할 수 있게 해준다.

트랜잭션 격리수준이란, 여러 트랜잭션 간의 작업 내용을 어떻게 공유하고 차단할 것인지를 결정하는 레벨이다.

---

## MySQL에서의 트랜잭션

트랜잭션은 하나의 논리적인 작업 단위에 하나의 쿼리든, 그 이상이든 관계 없이 논리적인 한 단위 자체가 100% 적용 되거나(Commit) 적용되지 않아야 함을(Rollback) 보장해준다. MySQL의 InnoDB 스토리지 엔진은 이러한 트랜잭션을 보장하며, 부분 업데이트를 방지하여 데이터의 정합성을 맞출 수 있도록 돕는다.

```sql
try {
	START TRANSACTION;
	INSERT INTO table_a ...;
	INSERT INTO table_b ...;
	COMMIT;
} catch (exception) {
	ROLLBACK;
}
```

### 트랜잭션 주의사항

1. 데이터베이스 커넥션을 가지고 있는 범위와 트랜잭션이 활성화 돼 있는 프로그램의 범위를 최소화 해야 한다.
2. 외부 API 작업이 있는 경우 반드시 트랜잭션에서 배제해야 한다.

   ⇒ API에 장애가 발생 할 경우 DBMS 서버가 높은 부하 상태로 빠지거나 위험한 상태에 빠지는 경우가 빈번히 나타난다.

---

## MySQL 엔진의 잠금

MySQL 엔진 레벨의 잠금은 모든 스토리지 엔진에 영향을 미치지만, 스토리지 엔진 레벨의 잠금은 스토리지 엔진 간 상호 영향을 미치지 않는다.

### 글로벌 락

MySQL 서버 전체에 영향을 주는 MySQL에서 제공하는 락 중에 가장 범위가 큰 잠금을 말한다. "FLUSH TABLES WITH READ LOCK" 명령으로 획득할 수 있다. 만약 한 세션에서 글로벌 락을 획득하면 다른 세션에서 SELECT 이외에 다른 문장은 대기 상태로 남게 된다. mysqldump로 일관된 백업을 받아야 할 때 사용한다.

### 테이블 락

개별 테이블 단위로 설정되는 잠금을 말한다. 명시적 또는 묵시적으로 획득이 가능한데, "LOCK TABLES table_name[ READ | WRITE ]" 명령으로 특정 테이블의 락을 획득할 수 있다. 명시적으로 획득한 잠금은 UNLOCK TABLES 명령으로 잠금을 해제할 수 있다.

묵시적 테이블 락은 MyISAM, MEMORY테이블에 데이터를 변경하는 쿼리를 실행하면 발생한다. InnoDB 테이블의 경우 스토리지 엔진 차원에서 레코드 기반의 잠금을 제공하기 때문에 단순 데이터 변경 쿼리로 묵시적 테이블 락이 설정되지는 않는다. DML은 무시되지만 DDL의 경우에는 영향을 미친다.

### 유저 락

GET_LOCK() 함수를 이용해서 임의로 잠금을 설정한다. 이 잠금의 대상은 테이블이나 레코드가 아니다. 사용자가 지정한 문자열에 대한 잠금이다.

### 네임 락

데이터베이스의 이름을 변경하는 경우 획득하는 잠금. RENAME TABLE a TO b와 같이 테이블의 이름을 변경하는 경우 자동으로 획득하는 잠금이다.

---

## InnoDB 스토리지 엔진의 잠금

InnoDB 스토리지 엔진은 MySQL에서 제공하는 잠금과는 별개로 스토리지 엔진 내부에서 레코드 기반의 잠금 방식을 탑재하고 있다. 이 레코드 기반의 잠금 방식 덕분에 MyISAM보다 훨씬 뛰어난 동시성 처리를 제공한다. `INNODB_TRX`, `INNODB_LOCKS`, `INNODB_LOCK_WAITS` 테이블을 조인해서 조회하면 대기중인 잠금, 해당 잠금을 가지고 있는 트랜잭션을 확인할 수 있고, 장시간 잠금을 가지고 있는 클라이언트를 종료시킬 수 있다.

### InnoDB의 잠금 방식

**비관적 잠금**

현재 트랜잭션에서 변경하고자 하는 레코드에 대해 잠금을 획득하고 변경 작업을 처리하는 방식. 다른 트랜잭션에서도 해당 레코드를 변경할 수 있다는 가정을 하기 때문에 먼저 잠금을 획득한다. 높은 동시성 처리에 비관적 잠금이 유리하다고 알려져 있어 InnoDB는 비관적 잠금 방식을 채택하고 있다.

**낙관적 잠금**

각 트랜잭션이 같은 레코드를 변경 할 가능성이 희박하다 가정하고 우선 변경 작업을 수행한 뒤 마지막에 잠금 충돌이 있었는지 확인한다. 문제가 있었다면 ROLLBACK 한다.

---

## InnoDB의 잠금 종류

InnoDB 스토리지 엔진은 레코드 기반의 잠금을 제공한다. 잠금 정보가 작은 공간으로 관리되기 때문에 레코드 락이 페이지 락, 테이블 락으로 레벨업 되는 경우는 없다. 일반 상용 DBMS와는 조금 다르게 레코드 락 뿐만 아니라 레코드와 레코드 사이의 간격을 잠그는 갭 락이라는 것이 존재한다.

### 레코드 락

레코드 자체만을 잠그는 락. 다른 상용 DBMS의 레코드 락과 동일한 역할을 한다. 한가지 차이점으로 InnoDB 스토리지 엔진은 레코드 자체가 아닌 인덱스의 레코드를 잠근다는 점이 있다. 인덱스가 없는 테이블도 내부적으로 클러스터 인덱스를 이용해 잠금을 설정한다.

### 갭 락

레코드 자체가 아닌 레코드와 바로 인접한 레코드 사이의 간격만을 잠그는 락. 넥스트 키 락의 일부로 사용된다.

### 넥스트 키 락

레코드 락과 갭 락을 합쳐 놓은 형태의 잠금. InnoDB의 갭 락이나 넥스트 키 락은 바이너리 로그에 기록되는 쿼리가 슬레이브에서 실행될 때 마스터에서 만들어 낸 결과와 동일한 결과를 만들어내도록 보장하는 것이 주 목적이다. 데드락이나 다른 트랜잭션을 기다리게 만드는 일이 빈번하기 때문에 가능하면 바이너리 로그 포맷을 ROW 형태로 바꿔서 넥스트 키 락이나 갭 락을 줄이는 것이 좋다.

### 자동 증가 락

AUTO_INCREMENT 컬럼이 사용된 테이블에 동시에 여러 레코드가 INSERT 되는 경우, 저장되는 각 레코드는 중복되지 않고 저장된 순서대로 증가한 일련번호 값을 가져야 한다. 이를 위해 InnoDB에서 내부적으로 AUTO_INCREMENT 락이라는 테이블 수준의 잠금을 사용한다. 하지만 아주 짧은 시간 동안만 걸렸다가 해제되는 락이라서 대부분의 경우 문제가 되지 않는다.

자동 증가 값은 한번 증가하면 절대 줄어들지 않는 이유가 AUTO_INCREMENT 잠금을 최소화하기 위해서다. INSERT 쿼리가 실패 하더라도 AUTO_INCREMENT 값은 다시 줄어들지 않고 그대로 남게 된다.

---

## 인덱스와 잠금

InnoDB의 잠금과 인덱스는 중요한 연관관계가 있다. InnoDB의 잠금은 레코드 자체를 잠그는 것이 아니라 인덱스를 잠그는 방식으로 동작하기 때문이다. 즉, 변경해야 할 레코드를 찾기 위해 검색한 인덱스의 레코드를 모두 잠가야 한다.

```sql
// first_name에 인덱스가 걸려 있는 상황을 가정
// first_name = 'Georgi' 가 253건임을 가정
mysql> UPDATE employees SET hire_date=NOW()
			 WHERE first_name = 'Georgi' AND last_name = 'Klassen';
// => UPDATE를 수행하는데에 253건에 대한 락이 걸린다.
```

---

## 트랜잭션 격리 수준과 잠금

레코드 기반의 바이너리 로그를 사용하거나 바이너리 로그를 사용하지 않는 경우 InnoDB의 갭 락이나 넥스트 키 락의 사용을 대폭 줄일 수 있다. 이렇게 하면 위 예제의 경우 처음 인덱스 검색 시 253건의 데이터에 대해 잠금을 걸지만, 나머지 조건을 비교해서 일치하지 않는 레코드는 잠금을 해제한다.

---

## MySQL의 격리 수준

트랜잭션 격리 수준이란 동시에 여러 트랜잭션이 처리 될 때 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하고 있는 데이터를 볼 수 있도록 허용할지 말지를 결정하는 것이다.

격리 수준이 높아질수록 MySQL의 처리 성능이 많이 떨어질 것으로 생각하는 개발자가 많은데, 사실 SERIALIZABLE 격리 수준이 아니라면 크게 성능의 개선이나 저하는 발생하지 않는다.

### READ UNCOMMITTED

각 트랜잭션에서 변경 내용이 COMMIT이나 ROLLBACK 여부에 상관 없이 다른 트랜잭션에서 보여진다.

어떤 트랜잭션에서 처리한 작업이 완료(COMMIT) 되지 않았는데도 다른 트랜잭션에서 볼 수 있게 되는 현상을 DIRTY READ라 한다. RDBMS 표준에서는 트랜잭션 격리 수준으로 인정하지 않을 정도로 정합성에 문제가 많은 격리 수준이다.

### READ COMMITTED

오라클 DBMS에서 기본적으로 사용되고 있는 격리 수준. 온라인에서 가장 많이 사용되고 있는 격리 수준이다. COMMIT이 완료된 데이터만 다른 트랜잭션에서 조회할 수 있기 때문에 DIRTY READ는 발생하지 않는다. 일반적으로 COMMIT 이전에는 백업 된 데이터인 언두 영역을 읽어오게 됨으로써 가능하다.

여기서는 NON-REPEATABLE READ 문제가 발생하는데, 이는 (조회하는 입장에서) 한 트랜잭션 안에서 다른 결과가 조회될 수 있음을 의미한다.

### REPETABLE READ

MySQL의 InnoDB 스토리지 엔진에서 기본적으로 사용되는 격리 수준. 바이너리 로그를 가진 MySQL의 장비에서는 최소 REPEATABLE READ 격리 수준 이상을 사용해야 한다. 언두 영역에 백업된 이전 데이터를 이용해 동일 트랜잭션 내에서는 동일한 결과를 보여줄 수 있도록 보장한다. SELECT 하는 입장에서 자신의 트랜잭션 번호보다 앞선 트랜잭션 번호에서 변경한 것들만 보게 되는 것이다.

REPEATABLE READ에서는 PHANTOM READ가 발생하는데, 조회하는 측에서 SELECT ...FOR UPDATE 쿼리를 실행하면 한 트랜잭션 안에서 레코드의 추가 혹은 변경 내역이 보였다가 사라지는 현상이 생기는 현상을 말한다. SELECT ...FOR UPDATE 쿼리는 SELECT 하는 레코드에 쓰기 잠금을 걸어야 하는데, 언두 레코드에는 잠금을 걸 수 없기 때문에 언두 영역의 변경 전 데이터를 가지고 오는 것이 아니라 현재 레코드의 값을 가져오게 된다. 이 과정에서 PHANTOM READ가 발생하게 된다.

### SERIALIZABLE

트랜잭션 격리 수준이 SERIALIZABLE로 설정되면 읽기 작업도 공유 잠금(읽기 잠금)을 획득해야 한다. 따라서 동시에 다른 트랜잭션은 그 레코드를 변경하지 못하게 된다. 즉, 한 트랜잭션에서 읽고 쓰는 레코드를 다른 트랜잭션에서는 절대 접근할 수 없는 것이다.

InnoDB 스토리지 엔진에서는 REPEATABLE READ 격리 수준에서도 이미 PHANTOM READ가 발생하지 않기 때문에, 굳이 SERIALIZABLE을 사용 할 필요성은 없다.
