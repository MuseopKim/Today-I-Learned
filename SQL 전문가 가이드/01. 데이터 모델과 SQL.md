------



## 정규화

### 제 1정규형 - 모든 속성은 반드시 하나의 값을 가져야 한다.

다중 값을 갖는 속성이 발견되면 제 1정규화를 고민 해볼 수 있다. 엔티티를 나누어 다중 값을 제거함으로써 속성을 더욱 명확하게 활용할 수 있다. 유형이 겹치는 중복 데이터 (ex. 주문 > 주문상품 1, 주문상품 2, ..., 주문상품 N) 가 한 엔티티안에 존재할 경우 또한 정규화를 통해 별도의 엔티티로 분리 할 수 있다.



### 제 2정규형 : 엔티티의 일반속성은 주식별자 전체에 종속적이어야 한다.

함수 종속성은 데이터들이 어떤 기준 값에 의해 종속 되는 현상을 말한다. 이 때, 기준 값을 '결정자', 종속 되는 값을 '종속자'라 한다. 엔티티의 일반 속성이 결정자에 완전 종속 되지 못한다면 이는 제 2정규형을 위배했다 할 수 있다. 이는 다음과 같은 문제를 야기한다. ('주문상세 - 상품' 엔티티의 관계를 예시로 설명 해보겠다.)

- 만약 주문 상품에 대한 상품명 등이 수정되면, 주문상세 엔티티의 모든 상품명이 수정 되어야 한다. 이로인해 많은 변경이 필요할 수 있다.

- 상품명을 모두 변경한다 해도 특정 시점에는 아직 변경중인 데이터가 있을 수 있고, 이때의 트랜잭션에서 일관되지 않은 데이터가 조회될 수 있다.

  이 경우 상품에 관한 속성들을 엔티티와 식별자로 별도 관리하게 되면, 일반속성은 주식별자 전체에 종속적이어야 한다는 제 2 정규형을 만족시킬 수 있다.

  

### 제 3정규형 - 일반속성 간에는 서로 종속적이지 않는다.

주문 엔티티에 고객 번호와 고객명이 모두 속해 있는 상황을 가정해보자. 이 때, 고객명은 고객 번호에 종속적이고, 고객 번호는 주문 번호에 종속적이게 된다. 고객명, 고객 번호가 주문 번호에 종속적이므로 제 2 정규형은 만족 하였으나 일반속성인 고객명이 또 다른 일반속성인 고객 번호에 종속적인 문제가 있어 제 3정규형에는 위배 된다.

따라서 이 경우에도 고객 번호와 고객명을 별도의 엔티티로 분리 할 필요가 있다.



### 반정규화와 성능

데이터의 중복을 줄여나가는 작업을 '정규화'라 하였다. '반정규화' 또는 '역정규화' 는  성능 개선을 위해 중복을 허락하는 것을 말한다. 하지만 이 경우 조회 성능의 향상은 기대할 수 있지만 입력, 수정, 삭제에 대한 성능은 반대로 저하될 수 있다.



------

## 관계와 조인

부모의 식별자를 자식에게 상속시키는 것을 관계를 맺는다고 표현한다. 이 때, 자식이 부모의 식별자를 자신의 식별자에 포함시키면 식별관계, 부모의 식별자를 포함시키지 않으면 비식별관계라 한다. 부모와 자식을 부모의 식별자로 매핑하면 조인을 통해 조회 시에 테이터를 결합 할 수 있다. 이를 조인(Join)이라 한다.

### 계층형 데이터 모델

보통의 조인은 두 엔티티 사이에서 발생하지만 때때로 자기 자신에게 관계가 발생하는 경우도 있다. 이를 Self-Join이라 한다. 이는 주로 계층 구조를 가진 데이터를 다룰 때 마주하게 되는데, 간단한 예로 쇼핑몰의 카테고리 사이에서 찾아볼 수 있다. (패션 - < 여성 의류, 남성 의류)

------



## 트랜잭션

트랜잭션은 데이터베이스의 논리적 연산 단위이다. 가장 쉽고 적합한 사례로 '계좌이체' 상황을 들 수 있다. 계좌이체가 발생하면 돈을 보내는 사람의 계좌는 돈이 차감되고, 이체를 받는 사람의 계좌에서는 돈이 늘어난다. 이 때, 두 행위는 전부 실행 되던지, 전부 취소 되던지 하나의 단위로 실행이 되어야 한다. (All or Nothing) 이러한 하나의 실행 단위를 '트랜잭션'이라 한다. 계좌이체와 같이 원자성이 보장되어야 하는 것에 대해서는 커밋의 단위를 하나로 반드시 묶어 줄 필요가 있다.



------



## Null 속성의 이해

### Null 값을 포함한 연산은 언제나 Null 이다

```
Null 값은 '아직 정의되지 않은 값' 또는 '현재 데이터를 입력할 수 없음' 을 뜻한다. 즉, 공백, 숫자 0과는 다른 값이다. 
```



### 집계 함수는 Null 값을 제외하고 처리한다

집계 함수는 Null 값을 제외 시킨 뒤 나머지 값을 연산하게 된다. COUNT 연산에는 Null 값도 포함하여 연산을 하고, AVG와 같은 연산에서는 Null 값을 제외 한 뒤 연산을 한다. 따라서 평균 값에 대한 계산을 한다하면, 계산식에 따라 그 기대 값이 달라질 수 있다. ex. Null을 포함하는 COUNT 연산을 하여 직접 나누는 경우, 또는 AVG 연산을 직접 사용 하는 경우



------



## 본질 식별자 vs 인조 식별자

식별자는 대체 여부에 따라 다음의 두가지로 나눌 수 있다.

- 본질 식별자 : 비즈니스에 의해 만들어진 식별자

- 인조 식별자 : 비즈니스와 관계 없이 본질 식별자의 복잡도로 인해 인위적으로 만든 식별자

  개발의 편의성을 위해  인조식별자를 남용하는 경우가 있다. 개발의 편의성은 증가하지만 어떠한 부작용이 있는지는 한번 살펴볼 필요가 있다.



### 중복 데이터로 인한 품질 문제

외부식별자를 사용하면 중복 데이터를 막을 수 없게 된다. 외부 식별자를 사용 함으로써 본질 식별자가 하던 '식별자의 중복 방지 역할' 을 상실하게 되기 때문이다.



### 불필요한 인덱스 생성

SQL에 대해 본질식별자로 구성하면 PK 인덱스를 그대로 활용할 수 있겠지만, 인조식별자로 구성한다면 IX1과 같은 인덱스를 추가로 생성해주어야 한다. 추가로 생성한 인덱스는 용량과 DML 성능에 영향을 줄 수 있다.



인조 식별자를 사용하는 것은 많은 장점이 있지만, 케이스에 따라 장단점을 한번 쯤 고민 해보고 사용 한다면 더 좋을 것이다.